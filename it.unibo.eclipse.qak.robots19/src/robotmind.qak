System robotmind
 
mqttBroker "localhost" : 1883    //192.168.1.18  192.168.43.229

//Event  userCmd        : userCmd(X)	//from GUI X = w | a | s | d | h 
Event  envCond        : envCond( CONDTYPE )        //from the environment 
Event  modelChanged   : modelChanged( TARGET, VALUE )
Event  modelContent   : content( VALUE ) 

Event  sonarRobot     : sonar( DISTANCE )	     //from  sonar on robot 
Event  sonar          : sonar(SONAR, DISTANCE)	 //from sonar in the robot environment          

Dispatch modelChange  : modelChange( TARGET, VALUE )
Dispatch robotCmd     : robotCmd( CMD )

Context ctxRobotMind  ip [host="localhost" port=8035]   -mqtt
Context ctxDummyForBasicRobot ip [host="otherhost" port=8005]   -mqtt

ExternalQActor basicrobot context ctxDummyForBasicRobot 

QActor resourcemodel context ctxRobotMind{
["var dobackstep = false"]
	State s0 initial {		
		solve( consult("sysRules.pl")	 )       
		solve( consult("resourceModel.pl")	 )
		solve( showResourceModel ) 		
	} 
	Goto waitModelChange
	
	State waitModelChange{ }
	Transition t0 whenMsg modelChange -> changeModel

	State changeModel{  
		printCurrentMessage 
		onMsg( modelChange : modelChange(internal,backstep ) ) { //introduced for the virtual robot			 
 			solve( model( _, _, state(movingForward) ) )
  			ifSolved ["dobackstep = true"]  else  ["dobackstep = false"]
		}
		onMsg( modelChange : modelChange( robot,V ) ) { // V= w | ...
			solve(  action( robot, move($payloadArg(1)) ) )  
			ifSolved emit modelChanged : modelChanged(  robot,  $payloadArg(1)  )  
			solve( model( A, R, STATE ) )
			["val RobotState = getCurSol(\"STATE\") "]
			emit modelContent : content( robot( $RobotState ) )
		} 
	}
	Goto doBackStep if "dobackstep" else waitModelChange
	
	State doBackStep{ 
			solve(  action( robot, move(s) ) )  
			emit modelChanged : modelChanged(robot,s)  //trigger move
			solve( model( A, R, STATE ) )
			["var RobotState = getCurSol(\"STATE\") "]
			emit modelContent : content( robot( $RobotState ) ) //export model content
			delay 200   
			solve(  action( robot, move(h) ) )  
			emit modelChanged : modelChanged(robot,h)
			solve( model( A, R, STATE ) )
			["RobotState = getCurSol(\"STATE\") "]
			emit modelContent : content( robot( $RobotState ) )		
			["dobackstep = false"]  //reset
	}
	Goto waitModelChange
}

QActor robotmind context ctxRobotMind{   
["var obstacle = false"]
	State s0 initial {	  
		println("ROBOT MIND STARTED")	
		forward basicrobot -m robotCmd : robotCmd( a )
		delay 700
		forward basicrobot -m robotCmd : robotCmd( d )
		delay 700
		forward basicrobot -m robotCmd : robotCmd( h )
	}
	Goto waitCmd
	 
	State waitCmd {		} 
	Transition t0 whenMsg   robotCmd     -> handleCmd
		          whenEvent envCond      -> handleEnvCond
		          whenEvent sonarRobot   -> handleSonarRobot
		          whenEvent modelChanged -> handleModelChanged
	
	State handleCmd{  //command from the frontend
		printCurrentMessage
 		onMsg( robotCmd : robotCmd(CMD) ) {
 			forward resourcemodel -m modelChange : modelChange(robot,$payloadArg(0)) 
		}
	} 
	Goto waitCmd
	
	State handleEnvCond{   
		printCurrentMessage
 		onMsg( envCond : envCond(CMD) ) {
 			forward resourcemodel -m modelChange : modelChange(robot,h) 
		}
	} 
	Goto waitCmd
 
 	State handleModelChanged{ //action to actuate
		printCurrentMessage
		onMsg ( modelChanged : modelChanged(robot,CMD) ){
			forward basicrobot -m robotCmd : robotCmd( $payloadArg(1) )
		}
	}
	Goto waitCmd
   
 	State handleSonarRobot{
 		printCurrentMessage
 		onMsg ( sonarRobot : sonar( DISTANCE ) ){
			["obstacle = Integer.parseInt( payloadArg(0) ) < 10 "]
 		}//onMsg 	 
 	}
	Goto handeObstacle if "obstacle" else waitCmd 
	
	State handeObstacle{		
		println("handeObstacle: going back START")  
		forward resourcemodel -m modelChange : modelChange(internal,backstep) 
	}
	Goto waitCmd
 
 }
