<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
<!--

body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin: 10;
    margin-right: 15px;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
    border-bottom: 1px solid #242424;
}

h1 {
    font-size: 150%;
    background-color: #b2c0ff;
}

h2 {
    background-color: #d9fbff;
    font-size: 110%;
}

h3 {
	background-color: #e6ccff;
    font-size: 80%;
}
h4 {
    background-color: #99ffcc;
    font-size: 100%;
}
#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 80%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #ccffff;
    color: #0033cc;
}
bc{
	font-family: "Arial";
	font-size: 80%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
k{
	font-family: "Arial";
	font-weight: bold;
    color: #990000;
	 
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	 
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	 
}
pre{
	font-family: "Helvetica";
	font-size: 70%;
	background-color: #fcf8c7; 
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	width: 800px;
    font-size: 18px;
}    
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}    
div.remark{
	background-color: #FFFC33;     
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}  
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}

  -->
</style>
    
<head>
   
<title>Lab11ISS</title></head>
    
<body>

<div class="body"> 

<h1>72939 - LAB11 | The RobotRadar system</h1> 
<a href="http://htmlpreview.github.com/?https://github.com/anatali/iss2019Lab/blob/master/LectureBologna1819.html" target="isslm">LabISS-lectures site</a></font> 
 
 <h2>Index</h2>
 <ol>
<li><a href="#lab11req">Requirements</a></li>
<li><a href="#lab11iot">Application Domain (IOT)</a></li>
<li><a href="#Methodology">Methodology</a></li>
<li><a href="#reqanalysis">Requirement Analysis</a></li>
<li><a href="#firstModel">A first model of the system Architecture</a></li>
<li><a href="#testplans">TestPlans</a></li>
<li><a href="#problemanalysis">Problem  Analysis</a></li>
<li><a href="#logicalarch">Logical Architecture</a></li>
<li><a href="#Project">Project</a></li>
<li><a href="#radaralone">The radar as a stand-alone system</a></li>
<li><a href="#mvcrefactoring">A MVC-based refactoring</a> </li>
 </ol>
  
 
<h2><a id="lab11req"/>Requirements</h2> 
<!--
<div class="req">
Design and build a software support for the development of (<tt>IOT</tt>) applications involving one or more 
<em>Differential Drive Robots</em> (<tt>DDR</tt>). The support must help an application designer in the following tasks:
<ol>
<li><em>sendMoveCmds</em>: send commands to move a <tt>DDR</tt></li>

<li><em>receiveSensorInfo</em>: receive (and show) information from the sensors put on the DDR.
</li>
<li><em>handleEnvCond</em>: allow a robot to be sensible to environment conditions, e.g. the value of the ambient temperature,
an alarm emitted by some external entity, etc.
 </li>
<li><em>manyDDRTypes</em>: allow the usage of both virtual and real robots built with different technologies</li>
</ol>
</div>	 
-->

<div class="req">
Design and build a software systems (named <bc>ddrworker</bc <!-- in project  it.unibo.eclipse.qak.ddrworker  -->) that allows an <em>human user</em> to interact with a single <em>Differential Drive Robot</em> (<tt>DDR</tt>) 
by using a <em>remote console</em> (running on a conventional PC or on a Smart Device) in order to:

<ol>
<li><em>sendMoveCmds</em>: send commands to <em>move</em> a <tt>DDR</tt> that could be a <bc>virtual</bc> or a <bc>real robot</bc>,
with reference to the <a href="#available">resources already available</a>.</li>

<li><em>receiveSensorInfo</em>: receive information from the  <bc>HC-SR04 sonar</bc> sensor mounted on the robot  and from
the sonars (if they exists) present in the robot working environment. </li>

<li><em>showSonarData</em>: show data coming forn the sonar-sensor  on a <em>radar GUI</em>:
<img src="./radarGui.png" alt="radarGui" width="10%" height="10%"/>
</li>
<li><em>handleConds</em>: allow the robot to <bc>stop</bc> its behavior under some specific condition, 
like for example an <b>alarm</b> emitted by some external entity, or when the <b>ambient temperature</b> overcomes a given limit value 
or when the robot <b>hits an obstacle</b>.
 </li>

</ol>
</div>

<div class="remark">
This system is intended to be a starting step towards the development of 
<a href="https://en.wikipedia.org/wiki/Internet_of_things" target="web">Internet of things</a>(<tt>IOT</tt>) applications.
See the section: <a href="#lab11iot">The Application Domain</a>
</div>


<h3 id="available">Resources already available</h3>
Besides the (open-source) software available from Internet, we can use software already developed by our company, and in particular:
<ul>
<li>A virtual environment (named <bc>WEnv</bc>) built in JavaScript, that includes a virtual robot that accepts commands 
sent on a<tt> TCP</tt> connection on port <tt>8999</tt>. 
See <a href="http://htmlpreview.github.com/?https://github.com/anatali/iss2019Lab/blob/master/it.unibo.robots19/userDocs/Lab9.html" target="lecture">Lab9.html</a> </li>
<li>A basic robot control software for physical ddr robots (<bc>BaseRobot</bc>), modeled as an  <tt>observable POJO</tt>.
See <a href="UsingRobots2019.pdf" target="lecture">UsingRobots2019.pdf sections 3 and 4</a>.</li>
<li>A software system written in Java that simulates the screen of a <bc>radar</bc>. 
The project  <tt>it.unibo.java.radar</tt> implements a software system able to display distance values on an output device 
that simulates the screen of a radar.  The deployment file is   <tt>radarPojo.jar</tt> .

 </li>
<!--  A IOT envelope (called mbot) of the BaseRobot that allows us to send commands on the network to a real
robot built upon a mBot robot.  -->
<!-- <li>A front-end system written in Node that provides a user interface and support for user-authentication.</li> -->
</ul>

<h3>Basic questions</h3>
Let us recall a set of basic questions that we can pose to ourselves at the starting of each new project (see also
the section <a href="#Questions">Questions</a>).
<ul>
<li><em>Incremental development</em>: Is it possible to organize the production in terms of a <tt>sequence of systems</tt>, each facing a more wide/complex
set of requirements so that each system can be designed and built as the <bc>incremental evolution</bc> of the previous one?</li>
<li><em>Top-down or bottom up?</em>: What is our starting point? Do we start by what is already available (by following a <tt>bottom-up</tt> approach) or 
do we follow a <tt>top-down</tt> approach that first detects a logic architecture of the system and afterward selects
the technology? </li>
<!-- <li><em>Requirement sequencing</em>Is it possible to order the set of requirements into a list of increasing complexity and to harmonize such a list
with the <bc>product backlog</bc> defined by our <tt>product-owner</tt>? </li> -->
</ul>

Of course, we will - sooner or later - use as much as possible the (hopefully corrected or at least tested) software
that our company has already built in the <tt>IOT</tt> domain. The intent however is to avoid the a-priori introduction of
such a software. 
<!--Rather, our aim is to introduce proper available software libraries, infrastructures, components
etc. as the proper consequence of our problem analysis or of our design choices. -->
In other words: 

<div class="remark">
we will not start from any available software, with the intent to discover what are the most appropriate resources
able to satisfy our needs <bc>after the analysis</bc> of the requirements  and of the problem.
</div>

<!--
Model Driven methodology (GeneXus)
Describe: Create a technology-independant representation of the desired application.
Forward Engineering: The specific model can be discarded and regenerated at any time.
Extensible: There are clear options to extend the model, which enable the developer to extend the final application using the specific language.
DRY: There are no duplicated definitions of concepts (Don't Repeat Yourself).

https://wiki.analog.com/resources/eval/user-guides/eval-adicup3029/smart_app/android_app
-->

<h2><a id="Methodology"/>Methodology</h2> 
<table>
<tr><td>
<img src="./Scrum-framework.jpg" alt="Scrum-framework" width="90%" height="90%"/>
</td>
<td>
<img src="./process.jpg" alt="process" width="90%" height="90%"/>
</td>
</tr>
</table>

<img src="./overviewScrum.jpg" alt="overviewScrum" width="100%" height="30%"/>

 


<!--
<br/><img src="./scrum1.png" alt="scrum1" /> <br/>-->



<h3>Technology (in)dependency and modeling</h3>
In the first phase of our development, we want to be <em>technology-aware</em> but also as much technology-independent
as possible. To achieve such a goal, we will start by building a <em>conceptual model</em> of the system. From
<a href="https://en.wikipedia.org/wiki/Systems_modeling" target="code">https://en.wikipedia.org/wiki/Systems_modeling</a>
we read:
<div class="remark">
A model is a representation of a system, made of the composition of concepts which are used to help
people know, understand, or simulate a subject the model represents.
</div>

<h3>Towards a Product Backlog</h3>
According to the <em>SCRUM</em> framework of software development, we will suppose that the product backlog defined
by the <tt>Product Owner</tt> allows us to satisfy the set of requirements in incremental way, by distinguishing among a
set of macro-steps. More precisely, we will follow a '<bc>zooming methodology</bc>' (see the video 
<a href="https://www.youtube.com/watch?v=0fKBhvDjuy0" target="web">Powers of Ten</a>):

<ol>
<li>The first step defines the <em>main components</em> of the logic architecture of the systems, by focusing on their
interaction. In this phase, the behavior of each component should be simply 'simulated' in order to reproduce a set of
interaction patterns, with the aim to introduce a proper set of <em>initial (integration, functional) Test-Plans</em>.</li>
<li><em>Refine</em> the logical architecture defined in the previous step, by including code that satisfies the requirements
in more detailed way or that satisfies more functional requirements.
.</li>

</ol>

<h3><a id="logicalarch"/>Logical Architecture</h3>
For <em>logical architecture</em> we intend here a software architecture that is defined as consequence of the
requirement/problem analysis phase, in the attempt to focus our attention <bc>on the problem itself</bc>, rather than on some specific
technology. We say that, during problem analysis, we are technology aware but not technology dependent.
<br/><br/>

<img src="./vision.png" alt="vision" width="80%" height="80%"/>
 <br/><br/>
The logical architecture will be progressively 'zoomed' into a project architecture
and a proper implementation and deployment.
<br/><br/>
The incremental approach will lead us to define a sequence of running models, that can be used as the reference
point for a sequence of <tt>SCRUM</tt> <bc>sprint</bc>, followed by proper <bc>sprint-review</bc> and <bc>sprint-retrospective</bc>.

<h2><a id="reqanalysis"/>Requirement Analysis</h2> 

After the (several) meetings with the customer, we can say that:

<ol>
<li>Our software system is a <bc>distributed system</bc> composed by two main entities: a <em>console</em> running on a <em>consoleNode</em> 
that can be a PC or on a SmartDevice and a (real or virtual) <em>robot</em>, running on its own <em>robotNode</em>.</li>
<li>The robot is equipped with a sonar (<em>sonar-robot</em>) put in front of it. Other sensors are, at the moment, 
excluded for costs reason.</li>
<li>To understand (or formally define) what is the meaning of the term <bc>robot</bc>, we must read
 <a href="UsingRobots2019.pdf" target="lecture">UsingRobots2019.pdf</a>. </li>
<li>The software running on the <em>consoleNode</em>  must allow the end-user to control the robot with very simple commands
(e.g. <tt>w, a, s, d, h</tt>).</li>
<li>A <em>console</em> running on a Smart Device could be conceived as a Application or as user-GUI running into  <bc>Browser</bc>. </li>
<li>The software running on the <em>robotNode</em> must execute the commands sent by the <em>human-user</em> via the <em>console</em> and must
be sensible to a set of conditions. Let us name, from now on, such a set with the term <em>envConds</em>.</li>
<li>The <em>envConds</em> set is actually given only with reference to examples, i.e. it is not clearly defined. However, the given examples
suggest two different type of conditions:
	<ul>
	<li>conditions related the <b>world external</b> to the system, e.g. alarms and temperature;</li>
	<li>conditions that <b>arise form the work of the system</b> itself, e.g. fining an obstacle.</li>
	</ul>
</li>
<li>It is not clear whether the <em>radarGUI</em> is shown in the <em>console</em> or it is a different system. The customer told us
that it is quite probable that in the future the requirement <em>showSonarData</em> and the related <em>radar GUI</em> will be delegated
to an external (sub)system.
At the moment, we can reuse the library <tt>radarPojo.jar</tt> (see <a href="#available">resources already available</a>).
</li>

</ol>

<h3><a id="firstModel"/>A first model of the system Architecture</h3>
At this stage, the system architecture can be represented as in the following, informal picture:

<center><table style="width:98%">
<tbody>	
<tr>
<td style="width:55%">
<img src="./robotRadarReq.png" alt="robotRadarReq" width="100%" height="30%"/>
<br/>
</td>
<td>
<m>
The structure of the <bc>information exchanged</bc> among the main components of the application is (at the moment) defined as follows:
<ul>
<li>console to robot: <ks>robotCmd : robotCmd(X) </ks> <kc>X=w|a|s|d|h</kc></li>
<li>from sonar : <ks>sonar : sonar( Name, Distance )</ks></li>
<li>robot to radar: <ks>polar : p( Distance, Angle )</ks></li>
<li>from environment: <ks>envCond : envCond(X)</ks></li>
</ul>

These definitions are very useful to assure interoperability, but they do not arise from the requirements; thus,
can be changed in the next models.
</m>
 
</td>
 </tr>
 </table>
</center>

Note that, at this stage, we do not introduce a full model for the <em>sonars</em>. Rather, we capture only the fact that a sonar is
a source of information (see <bc>sonar/2</bc> in the picture above).



<h4>Towards <bc>Requirements traceability</bc>) </h4>
A better specification of the system architecture can be given by introducing a model written in a machine-understandable language. 
For example, a   
<a href="http://htmlpreview.github.com/?https://github.com/anatali/iss2019Lab/blob/master/it.unibo.qakactor/userDocs/LabQak.html" target="lecture">QActor</a>
specification allows us to introduce a description that associates each running component (actor) with the requirements 
(see <a href="https://en.wikipedia.org/wiki/Requirements_traceability" target="web">Requirements traceability</a>):

<pre>
------------------------------------------------------------------------------------------------------------------------------
System ddrworker
Event    envCond   : envCond( CONDTYPE )            //from the environment  
Event    sonar     : sonar(SONAR, DISTANCE)	        //from sonar in the robot environment   
Event    sonarRobot: sonar( DISTANCE )	            //from  sonar on robot 

Dispatch robotCmd  : robotCmd(X)	                //from console to robot
Dispatch polar     : p( Distance, Angle )           //from robot to radar

Context <ks>ctxRobotReq</ks> ip [host="localhost" port=8025]

<kc>//requirements: <ks>human user interaction, sendMoveCmds</ks></kc>
QActor <k>consolereq</k> context ctxRobotReq{ <kc>//Provides a user GUI and <k>Forwards <ks>robotCmd</ks> to robotplayerreq</k></kc> }        

<kc>//requirements: <ks>sendMoveCmds.move, handleConds, receiveSensorInfo, showSonarData</ks></kc>
QActor <k>robotreq</k> context ctxRobotReq{ <kc>/* Handles <ks>robotCmd</ks>, <ks>sonar</ks>  <ks>envCond</ks>;  
	                                                     moves the robot and <k>Forwards <ks>polar</ks> to radarreq</k></kc> */ }    

<kc>//requirements: <ks>showSonarData</ks></kc></kc>
QActor <k>radarreq</k> context ctxRobotReq{  <kc>//Uses <ks>radarPojo.jar</ks> to show sonar data</kc> }     
------------------------------------------------------------------------------------------------------------------------------
 </pre>

<center><table style="width:98%">
<tbody>	
<tr>
<td style="width:60%">
<img src="./robotRadarReq1.png" alt="robotRadarReq1" width="95%" height="30%"/>
</td>
<td>
<m>
<li>The first prototype aims at capturing the <em>fundamental aspects</em> of the system we have to build.<br/></br></li>
<li>There is a <bc>single context</bc>, in order to just check  the logical interactions and to fix the main business logic.<br/></br></li>
<li>The <bc>business logic</bc> is almost entirely included in <tt>robotreq</tt> actor.</li>
 
</m>
 
</td>
 </tr>
 </table>
</center>

Note that in this first model:
<ul>
<li>The names of the actors ends with the suffix <bc>req</bc> to recall that they are part of the first model, related
to our requirement analysis. These names will change in our next model refinements.</li>
<li>The <em>responsibility</em> to satisfy the requirements is already <b>distributed among the actors</b>.</li>
<li>Data identified with the names <bc>userCmd</bc>, <bc>robotCmd</bc> and <bc>polar</bc> are defined as <em>Dispatches</em>.
In fact, from the requirements, we deduce that each of them has a specific destination.
</li>
<li>Data identified with the names <bc>envCond</bc> and <bc>sonar</bc> are defined each as <em>Events</em>.
In fact, <bc>envCond</bc> models information generated by the 'world' outside the system, while <bc>sonar</bc> is information
generated by the virtual robot or by (sonars working in) the robot environment. 
In both cases, the entity that generates this data cannot known the names of the actors
working in our system.</li>    
</ul> 

<div class="remark">
An important point is to exclude from the <em>console</em> any responsibility rleated to the business logic.
</div>


<h2><a id="testplans"/>Test plans</h2>   
This first model is quite simple but is provides a basic skeleton for the system to build a reference point for our next development steps.
Moroever, it can be used to define a set of <bc>test plans</bc>, i.e. the specification of tests that must be run with success as soon as some code
is available.

<h3>An example</h3>
Example of functional test-plans could be:
<ul>
<li>If the robot receives the command <bc>robotCmd:robotCmd(X)</bc>, the robot state must change from <tt>stopped</tt> to <tt>movingForward</tt> </li>
<li>If the robot is in the state <tt>movingForward</tt> and the event <bc>envCond : envCond(alarm(fire))</bc> is emitted,
the robot state must change to <tt>stopped</tt> 'as soon as possibile' </li>
<li>...</li>
</ul>

We note that the effort to declare (even if in informal way) a set of test-plan in explcit way, leads us to the idea of introducing the concept of 
<bc>robot state</bc>.
We will return on this point after the section <a href="#mvcrefactoring">A MVC-based refactoring</a>.

<h2><a id="problemanalysis"/>Problem analysis</h2> 
The main goal of problem analysis can be summarized as follows:
<ol>
<li>understand the (technical) problems posed by the requirements;</li>
<li>identify the best tools/libraries/supports etc. necessary and/or useful for building the system;</li>
<li>clarify the constraints  (human, technical, economical, etc.) related to both the software
<em> product</em> to build and the software <em>production process</em>;</li>
<li>define a <bc>logical architecture</bc> of the system and a <em>first working prototype</em> to show to the customer
at the end of our <em>first sprint</em>.
</li>
 
</ol>

In the context of <tt>SCRUM</tt>, one or more of these steps will be redone in the <em>sprint-review meetings</em>.

<br/><br/>
In our case, we can say that:
<ol>
<li>The system is distributed and <bc>effective operational supports</bc> are required. At the current state of the art, there are
several possible candidates, whose number is increasing. We will start from the support given by the <tt>QAk-infrastructure</tt>.
In a second moment, when the requirements and the consequent logic of the system will be more stable, we will discuss
how to introduce other, different supports, with particular reference to <tt>MQTT</tt> and <tt> Web</tt>.<br/><br/></li>



<li>The system requires a <tt>GUI</tt> for human-user interaction that can be created by the <bc>console</bc> component.
The <tt>GUI</tt> can be a built by reusing a <tt>POJO</tt> already available, with the addition of an adapter to send information
to the <bc>console</bc>. A possible adapter can be <a href="../src/resources/guiSupport.kt" target="code">guiSupport.kt</a>
that sends the dispatch:
<pre>
Dispatch <ks>userCmd : userCmd(X)</ks>		<kc>//with X = w | a | s | d | h</kc> 
</pre>
</li>

<li>The <bc>robot</bc> component represents the control part of the system. To make such a control independent form the
particular type of robot to move (<tt>virtual, real-mbot, real-nano</tt>, etc.) it is opportune to introduce a resource 
<a href="../src/resources/robotSupport.kt" target="code">robotSupport.kt</a> working as a robot-
<a href="https://en.wikipedia.org/wiki/Facade_pattern" target="web">facade</a>.
<!--
<br/></br>
From  <a href="UsingRobots2019.pdf" target="lecture">UsingRobots2019.pdf sections 3 and 4</a>, we discover that each robot type
'emit' sonar event with its own pattern. In particular:
<ul>
<li><em>mbot</em> sends over a TCP connection data of the form: </li>
<li></li>
</ul>
-->
<br/></br>
</li>

<li>The <bc>robot</bc> control must work as a <em>proactive/reactive</em> component, since it must execute user commands without
loosing the capability to react to <em>envCond</em> events and to update the radar. With reference to the  motto
<i>divide et impera</i>, it is opportune to distribute some responsibility by introducing another actor to handle 
<bc>sonar</bc> events and to interact with the radar:

<pre>
<kc>//requirements: <ks>sendMoveCmds.move, handleConds</ks></kc>
QActor <k>robotreq</k> context ctxRobotReq{ <kc>// Handles <ks>robotCmd</ks>, <ks>envCond</ks>; moves the robot }    

<kc>//requirements: <ks>receiveSensorInfo, showSonarData</ks></kc>
QActor <k>sonarhandler</k> context ctxRobotReq{  <kc>//Handles <ks>sonar</ks> and <k>Forwards <ks>polar</ks> to radarreq</k></kc> }    

</pre>

</li>
<li>The <bc>radar</bc> actor must show on the <em>radarGUI</em> the sonar data enclosed in the dispatch <bc>polar : p( Distance, Angle )</bc>.
To this end, it can reuse the <tt>POJO</tt> facade given by the library <tt>radarPojo.jar</tt>:

<pre>
package radarPojo;
import it.unibo.radar.common.RadarControl;
public class radarSupport {
private  static RadarControl radarControl;

public static void <k>setUpRadarGui</k>( ) {
		try {
			radarControl = new RadarControl( null );
		} catch (Exception e) {
 			e.printStackTrace();
		}
	}
	public static void <k>update</k>(  String dist, String theta ){
		if( radarControl != null ) radarControl.update(   dist,   theta );
	}
}
</pre>
</li>

<li>The problem of a <em>GUI for a smart device</em> is not trivial, since the development of an Application requires
effort and probably introduces technology lock-in. On the other side, a browser-based implementation of the user-GUI 
requires the introduction of a Web infrastructure. Let us postpone this problem to a next sprint.</li>
</ol>


<h3>Logical architecture</h3>
With the help of the supports built  after the problem analysis phase, we can define in more detail the logical architecture of the system
and our first working prototype. Let us start from the declaration of the messages and events:

<pre>
Event    envCond   : envCond( CONDTYPE )            //from the environment (simulated)
Event    sonar     : sonar(SONAR, DISTANCE)	        //from sonar in the robot environment   
Event    sonarRobot: sonar( DISTANCE )	            //from  sonar on robot 

Dispatch userCmd   : userCmd(X)		                //from GUI to console
Dispatch robotCmd  : robotCmd(X)	                //from console to robot
Dispatch polar     : p( Distance, Angle )           //from robot to radar
</pre>


Let us start from the actor that captures our business logic.


<h4><a id=""/>The robot</h4> 
The principal actor of our system is a proactive/reactive component that executes user commands without
loosing the capability to react to <bc>envCond</bc> events:
<pre>
<k>QActor</k> robotreq <k>context</k> ctxRobotReq{   
	<k>State</k> s0 <k>initial</k> { <k>run</k> <ks>resources.robotSupport.create( myself, "virtual" )</ks>	}
	<k>Goto</k> waitCmd
	
	<k>State</k> waitCmd{ }
	<k>Transition</k> t0 <k>whenMsg</k>  robotCmd -> handleCmd
	             <k> whenEvent</k> envCond -> handleCond
	
	<k>State</k> handleCmd{
		<k>onMsg</k> ( robotCmd : robotCmd(CMD) ){	<k>run</k> <ks>resources.robotSupport.move( "msg(${payloadArg(0)})"  )</ks> }	
	}
	<k>Goto</k> waitCmd
	
	<k>State</k> handleCond{ <k>run</k> <ks>resources.robotSupport.move( "msg(stop)"  )</ks> }
	<k>Goto</k> waitCmd
}
</pre>

This version of the <bc>robot</bc> actor does not handle the event <em>sonar</em> emitted by the virtual robot.  This task is delegated
to the <bc>sonarhandler</bc> that <tt>forward</tt> the message  <em>polar</em> to the actor <bc>radar</bc> .

<h4><a id=""/>The sonarhandler</h4> 
  
<pre> 
	State waitForEvents{  }      
   	Transition t0 whenEvent sonar      ->  sendToRadar
   	              whenEvent sonarRobot ->  sendToRadar
   	               
 	State sendToRadar{                      
 		printCurrentMessage                                        
 		onMsg ( sonar  : sonar( SONAR, DISTANCE ) ){     
			[" val D = Integer.parseInt( payloadArg(1) ) * 5"] 
			forward radarreq -m polar : p( $D, 90  ) 
 		}
 		onMsg ( sonarRobot : sonar( DISTANCE ) ){     
			[" val D = Integer.parseInt( payloadArg(0) ) * 5"] 
			forward radarreq -m polar : p( $D, 180  ) 
 		}
 	} 
 	Goto waitForEvents
</pre>

The full code is in <a href="../src/robotWorker.qak" target="code">robotWorker.qak</a>.
 
 <h2><a id="Project"/>Project</h2> 

 
 Here we:
 <ol>
 <li>Provide the proper support for the different types of robots. 
 See <a href="../src/resources/robotSupport.kt" target="code">robotSupport.kt</a>,
<a href="../src/resources/clientWenvObjTcp.kt" target="code">clientWenvObjTcp.kt</a> (for the virtual robot)
and
<a href="../src/resources/mbotSupport.kt" target="code">mbotSupport.kt</a> (for the <tt>mbot</tt> robot). </li>
 <li>Distribute the actors into proper different contexts. </li>
 <li>Test the system on the network.</li>
 <li>Refactor the <bc>robot</bc> control according to the <bc>MVC</bc> design pattern.</li>
 <li>Substitute the  <tt>QAk-infrastructure</tt> with a <tt>MQTT</tt> support.</li>
 <li>Define a better <tt>GUI</tt> and/or a <tt>GUI</tt> for a <bc>smart device</bc>. </li>
 </ol>
 

 The first 3 points are left to the reader. 
 
   
 Let us now show how the radar can  become a stand-alone system.
 
 <h3 id="radaralone">The radar as a stand-alone system</h3>
 <ol>
 <li>Remove <bc>radarreq</bc> from the system model</li>
 <li>Redefine the model for the radar. See <a href="../src/radar.qak" target="code">radar.qak</a>.</li>
 <li>Modify the <em>sonarhandler</em> by substituting <tt>forward</tt> with <bc>publish</bc>.</li>
 </ol>
 
 <center><table style="width:98%">
<tbody>	
<tr>
<td style="width:38%">
<pre>
 QActor <ks>sonarhandler</ks> context ctxRobotReq{
 	State init initial{
		["<k>connectToMqttBroker</k>(\"tcp://127.0.0.1:1883\")"]		
	}         
	Goto waitForEvents	   
	State waitForEvents{  }      
   	Transition t0 whenEvent sonar      ->  sendToRadar
   	              whenEvent sonarRobot ->  sendToRadar   	               
 	State sendToRadar{                      
 		printCurrentMessage                                        
 		onMsg ( sonar  : sonar( SONAR, DISTANCE ) ){     
[" val D = Integer.parseInt( payloadArg(1) ) * 5"] <kc>//amplify distance</kc>
		<kc>//forward radarreq -m polar : p( $D, 90  )</kc> 
["val <ks>evtopic</ks> = \"<k>unibo/qak/events</k>\"
val evpolar = MsgUtil.buildEvent(\"$name\",\"polar\", \"p( $D, 90  )\").toString()
<k>publish</k>(evpolar, <ks>evtopic</ks> ) "]
 		}
 }
 </pre></td>
<td>
<m>The operations <bc>connectToMqttBroker</bc>, <bc>publish</bc> and <bc>subscribe</bc>  are built-in in <em>ActorBasic</em>.
At the moment they are not included in the <tt>qak</tt> language.
<div class="remark">
WARNING: the system works, but <bc>is it logically correct?</bc><br/><br/>
Is it right to substitute a point-to-point interaction expressed by <ks>forward</ks> with a 
one-to-many interaction expressed by <ks>publish</ks>?
</div>

See on the network, e.g. 
<li><a href="http://www.steves-internet-guide.com/mqtt-security-mechanisms/" target="web">MQTT Security Fundamentals</a></li>
<li><a href="https://www.hivemq.com/mqtt-security-fundamentals/" target="web">MQTT Security Fundamentals</a></li>
<li><a href="https://www.trendmicro.com/vinfo/us/security/news/internet-of-things/mqtt-and-coap-security-and-privacy-issues-in-iot-and-iiot-communication-protocols" target="web">
MQTT & CoAP:Security and Privacy Issues in IoT</a></li>


</m>
</td>
 </tr>
 </table>
</center>

 
 <br/><br/>
  
<center><table style="width:98%">
<tbody>	
<tr>
<td style="width:60%">
<img src="./robotRadarViaMqtt.png" alt="robotRadarViaMqtt" width="95%" height="30%"/>
</td>
<td>
<m>
The radar is now a stand-alone system that receives <tt>polar</tt> events <bc>published</bc> on a <tt>MQTT</tt> broker by the robot.
<br/><br/>
The radar performs a <bc>subscribe</bc> to the topic <ks>unibo/qak/events</ks>. 
<div class="remark">
WARNING: without proper security, anyone that knows the address of the <tt>MQTT</tt> broker and the name of the topic, can receive <ks>polar</ks> events.
</div>
</m>
</td>
 </tr>
 </table>
</center>
<br/><br/>
Since we must change  the <tt>qak</tt> model by using a <ks>publish</ks> at the place of a <ks>forward</ks>, we ask
ourselves if it possible to avoid any modification in the code of <bc>sonarhandler</bc>. 
The answer is 'yes': it is sufficient to include the flag <bc>-mqtt</bc> in
the declaration of the context <tt>ctxRobotReq</tt> as done in <a href="../src/radar.qak" target="code">radar.qak</a>.
See <a href="http://htmlpreview.github.com/?https://github.com/anatali/iss2019Lab/blob/master/it.unibo.qakactor/userDocs/LabQak.html#mqtt">LabQak.html: Using MQTT</a>.


 <div class="req">
<em>Todo (Radar with sonar HC-SR04)</em>: Launch the system for a real robot equipped with a sonar <bc>HC-SR04</bc> and look at the radar
 </div>

 
<h2><a id="mvcrefactoring"/>A MVC-based refactoring</h2> 
Let us introduce a new requirement: 
 <div class="req">
<em>Introspection</em>: The system must be able to  <em>show relevant information</em> to the user  about the <em>state</em>
of the system and of the external world. For example, the system should show the current state of robot, including its
position (assuming that it moves into a room with a flat floor) and the value of temperature in the room.
 </div>
 
Now a new 'sprint' related to requirement analysis is necessary, in order to fix with the customer the meaning of several terms,
in particular <tt>'show',  'relevant information', 'state of the robot', 'robot position'</tt>.
<br/><br/>
We entrust the reader with such a task. 
For our part, Let us show how an actor (<bc>introspector</bc>) can show the structure of system. 

<h3>Introspection: the system structure</h3>
 
 <pre>
QActor <k>introspector</k> context ctxRobotReq{
	State init initial{
		solve( <ks> consult("sysRules.pl")</ks>	 )       
		solve( <ks>consult("ddrworker.pl")</ks>	 )  
		solve( <ks>showSystemConfiguration</ks> ) <kc>//showSystemConfiguration is defined in sysRules</kc>
	}
}
</pre> 

Note that the facts stored in the file <bc>ddrworker.pl</bc> represent give us information about the structure of the system.
The actor executes the rule <bc>showSystemConfiguration</bc> (written in <em>sysRules.pl</em>) to produce the following output:

 <pre>
&&&&&&&&&&&&&&&&&&SysRules&&&&&&&&&&&&&&&&&&&&
CONTEXTS IN THE SYSTEM:
context(ctxrobotreq,localhost,'TCP','8025')
ACTORS   IN THE SYSTEM:
qactor(consolereq,ctxrobotreq,'it.unibo.consolereq.Consolereq')
qactor(robotreq,ctxrobotreq,'it.unibo.robotreq.Robotreq')
qactor(sonarhandler,ctxrobotreq,'it.unibo.sonarhandler.Sonarhandler')
qactor(introspector,ctxrobotreq,'it.unibo.introspector.Introspector')
&&&&&&&&&&&&&&&&&&SysRules&&&&&&&&&&&&&&&&&&&&
</pre>

<h3>Resource model</h3>

During problem analysis, we can state that requirement similar to <em>Introspection</em> appear in the <tt>IOT</tt> domain
andd in particular in the <em>Web Of Things</em> (<bc>WOT</bc>).<br/><br/>

<center><table style="width:98%">
<tbody>	

<tr>
<td style="width:60%">
<img src="./portAdapterArch.png" alt="portAdapterArch" width="95%" height="30%"/>
</td>
<td> 
<img src="./wotBook.jpg" alt="wotBook" width="40%" height="30%"/><br/>

<m>
From the <tt>Guinard/Trifa WOT</tt> book, we read (pg. 225) :<br/>
We need a method to describe what a device is and does. In other words, we need a <bc>conceptual model</bc> of
a web Thing (a <em>WebThingModel</em>) that can describe the resources of a web Thing using a set of well-known
concepts.

</m>
</td>
 </tr>
 </table>
</center>

The architecture shown on the left in the figure represents the reference system architecture in these domains,
known ad hexagoal architecture or port/adapter pattern (see for example
<a href="https://softwarecampament.wordpress.com/portsadapters/" target="web">Ports and Adapters Pattern (Hexagonal Architecture)</a>. 


<h3>Hexagonal architecture</h3>
The main aim of this architecture is to decouple the application's core logic from the services it uses. 
This allows different services to be "plugged in", and it allows the application to be run without these services.
<br/><br/>
The <em>connection between the inside and the outside part</em> of the system is realized via abstractions called 
<bc>ports</bc> and their implementation counterparts called <bc>adapters</bc>.

<center><table style="width:98%">
<tbody>	

<tr>
<td style="width:15%">
<img src="./portAdapter.png" alt="portAdapter" width="80%" height="30%"/>
</td>
<td> 
<m>
<ul>
 <li>The <em>business logic</em> of an application consists of the algorithms that are essential to its purpose. 
They implement the <em>use cases</em> that are the heart of the application. 
When you change them, you change the essence of the application.
</li>
<li>The <em>services</em> are not essential. They can be replaced without changing the purpose of the application. 
Examples: database access and other types of storage, user interface components, 
e-mail and other communication components, hardware devices.</li>
<li>The business logic can be <em>tested independent of outside services</em>.</li>
<li>
It is <em>easy to replace services</em> by other ones that are more fit in view of changing requirements.
</ul>

</m>
</td>
 </tr>
 </table>
</center>


At the center, there is the model of the resources and the structure of system can be viewed an instance of the
<bc>MVC</bc> pattern.

<h3>The pattern MVC</h3>

<center><table style="width:98%">
<tbody>	

<tr>
<td style="width:70%">
<img src="./mvc.png" alt="mvc" width="100%" height="40%"/>
</td>
<td> 


<m>
Today, it is quite common to express the resource model in <tt>JSON</tt>.

<img src="./resourceModelJson1.png" alt="resourceModelJson1" width="60%" height="32%"/>

<pre>
{
"env": {
	"actuators": {
		"leds": {
			"led1": {
			"name": "LED 1",
			"value": false,
			"gpio": 4
			},
			"led2": {
			...
			}
		}
	} 
	...
}
</pre>

</m>
</td>
 </tr>
 </table>
</center>


<h3>A resource model expressed in Prolog</h3>
While it is nowadays quite common to express the resource model in <tt>JSON</tt>, let us introduce an example of resource model
by using Prolog facts :



<pre>

<ks>model( actuator, robot, state(V) ).</ks>	<kc>//V = movingForward | movingBackward | rotateLeft | rotateRight | stopped</kc>

</pre>

The rules to access and to change the model cane be expressed in Prolog too:

<center><table style="width:98%">
<tbody>	

<tr>
<td style="width:60%">
Code in <a href="../ddrWorkerResourceModel.pl" target="code">ddrWorkerResourceModel.pl</a>
<pre>
<ks>model( actuator, robot, state(stopped) ).</ks> <kc>%% initial state</kc>

action(robot, move(w)) :- changeModel( actuator, robot, movingForward  ).
action(robot, move(s)) :- changeModel( actuator, robot, movingBackward ).
action(robot, move(a)) :- changeModel( actuator, robot, rotateLeft     ).
action(robot, move(d)) :- changeModel( actuator, robot, rotateRight    ).
action(robot, move(h)) :- changeModel( actuator, robot, stopped        ).


changeModel( CATEG, NAME, VALUE ) :-
   replaceRule( model(C,N,_),  model(C,N,state(VALUE)) ),
   <ks>showResourceModel</ks>.  <kc>%% at each change, show the model</kc>
				
showResourceModel :- 
	stdout <- print("[ "),
	<ks>model( CATEG, NAME, STATE ),</ks>
 	stdout <- print( model( CATEG, NAME, STATE ) ),
	stdout <- println(" ]").

</pre>
<m>
The actor <em>resourcemodel</em> (code on the left) interacts with the resource model and with the other actors.
</m>
<img src="./hexRobotMvc.png" alt="hexRobotMvc" width="90%" height="32%"/>
</td>
<td> 
<pre>

<k>Event</k>  local_userCmd : userCmd(X)	<kc>//from GUI  X = w | a | s | d | h </kc>
<k>Event</k>  modelChanged  : modelChanged( TARGET, VALUE )
<k>Dispatch</k> robotCmd    : robotCmd(X)
...
<k>QActor</k> resourcemodel <k>context</k> ctxRobotMvc{
	State s0 initial {	 //load the 	
		<k>solve</k>( consult("sysRules.pl")	 )       
		<k>solve</k>( consult("ddrWorkerResourceModel.pl")) 
		<k>solve</k>( <ks>showResourceModel</ks> ) 		
	}
	Goto waitModelChange
	
	State waitModelChange{}
	Transition t0 <k>whenEvent</k> <ks>modelChange</ks> -> changeModel

	State changeModel{
		<k>onMsg</k>( <ks>modelChange : modelChange( robot,V )</ks> ) { <kc>// V= w | ...</kc>
			<k>solve</k>(  <ks>action( robot, move($payloadArg(1)) )</ks> )  
			<kc>//emit makes  resourcemodel an observable</kc>
			<k>emit</k> <ks>modelChanged : modelChanged(robot,$payloadArg(1))  </ks>
		} 
	}
	Goto waitModelChange
}

</pre> 
<m>
The full code is in <a href="../src/ddrWorkerMvc.qak" target="code">ddrWorkerMvc.qak</a> 
</m>
</td>
 </tr>
 </table>
</center>
 
 <div class="req">
<em>Todo (TestPlans)</em>: Define in a formal way (using <bc>JUnit</bc>) a set of test plan for the system.
</div>

<!--
 <h3>Access to the model with CoAP</h3>
Todo 
--> 
 
 

 
<h2><a id="lab11iot"/>The Application Domain</h2> 

<img src="./iot3.png" alt="iot0" width="100%" height="100%"/>
<br/><br/>
<img src="./iot4.png" alt="iot4" width="60%" height="60%"/>
<img src="./iot0.png" alt="iot0" width="70%" height="70%"/>
<img src="./iotRobot.png" alt="iotRobot" width="60%" height="60%"/>


<h2 id="Questions">Questions</h2>
<pre>
Quando inizio ad occuparmi del Testing del sistema?

- Cosa avrò in mano quando ho finito la fase di Analisi dei Requisiti?

- Cosa avrò in mano quando ho finito la fase di Analisi del Problema?

- Ammettendo di seguire un approccio incrementale evolutivo sarò in grado, e fino a che punto, di
implementare dei sistemi che evolvono in maniera monotona crescente? Andrò sempre dritto verso la
meta oppure devo mettere in conto che avrò dei ripensamenti durante la fase di feedback?

- Ma che cosa intende realmente Scrum quando parla di Sprint Review?

- Cosa intende realmente Scrum quando parla di Sprint Retrospective? 
</pre>

</div>
<div style="background-color:rgba(86, 56, 253, 0.9); width:100%;text-align:center;font-size:small;color:white">
By AN Unibo-DISI    
</div> 
</body>
</html>