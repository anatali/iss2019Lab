<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
<!--

body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin: 10;
    margin-right: 15px;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
    border-bottom: 1px solid #242424;
}

h1 {
    font-size: 150%;
    background-color: #b2c0ff;
}

h2 {
    background-color: #d9fbff;
    font-size: 110%;
}

h3 {
	background-color: #e6ccff;
    font-size: 80%;
}
h4 {
    background-color: #99ffcc;
    font-size: 100%;
}
#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 80%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #ccffff;
    color: #0033cc;
}
bc{
	font-family: "Arial";
	font-size: 80%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
k{
	font-family: "Arial";
	font-weight: bold;
    color: #990000;
	 
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	 
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	 
}
pre{
	font-family: "Helvetica";
	font-size: 70%;
	background-color: #fcf8c7; 
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	width: 800px;
    font-size: 18px;
}    
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}    
div.remark{
	background-color: #FFFC33;     
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}  
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}

  -->
</style>
    
<head>
   
<title>Lab11ISS</title></head>
    
<body>

<div class="body"> 

<h1>72939 - LAB11 | The RobotRadar system</h1> 
<a href="http://htmlpreview.github.com/?https://github.com/anatali/iss2019Lab/blob/master/LectureBologna1819.html" target="isslm">LabISS-lectures site</a></font> 
 
 <h2>Index</h2>
 <ol>
<li><a href="#lab11req">Requirements</a></li>
<li><a href="#lab11iot">Domain (IOT)</a></li>
<li><a href="#Methodology">Methodology</a></li>
<li><a href="#reqanalysis">Requirement Analysis</a></li>
<li><a href="#firstModel">A first model of the system Architecture</a></li>
<li><a href="#problemanalysis">Problem  Analysis</a></li>

<li><a href="#logicalarch">Logical Architecture</a></li>
<li><a href="#Project">Project</a></li>
<li></li>
<li></li>
 </ol>
 
 
<h2><a id="lab11req"/>Requirements</h2> 
<!--
<div class="req">
Design and build a software support for the development of (<tt>IOT</tt>) applications involving one or more 
<em>Differential Drive Robots</em> (<tt>DDR</tt>). The support must help an application designer in the following tasks:
<ol>
<li><em>sendMoveCmds</em>: send commands to move a <tt>DDR</tt></li>

<li><em>receiveSensorInfo</em>: receive (and show) information from the sensors put on the DDR.
</li>
<li><em>handleEnvCond</em>: allow a robot to be sensible to environment conditions, e.g. the value of the ambient temperature,
an alarm emitted by some external entity, etc.
 </li>
<li><em>manyDDRTypes</em>: allow the usage of both virtual and real robots built with different technologies</li>
</ol>
</div>	 
-->

<div class="req">
Design and build a software systems (named <bc>ddrworker</bc <!-- in project  it.unibo.eclipse.qak.ddrworker  -->) that allows an <em>human user</em> to interact with a single <em>Differential Drive Robot</em> (<tt>DDR</tt>) 
by using a <em>remote console</em> (running on a conventional PC or on a Smart Device) in order to:

<ol>
<li><em>sendMoveCmds</em>: send commands to <em>move</em> a <tt>DDR</tt> that could be a <bc>virtual</bc> or a <bc>real robot</bc>,
with reference to the <a href="#available">resources already available</a>.</li>

<li><em>receiveSensorInfo</em>: receive information from the  <bc>HC-SR04 sonar</bc> sensor mounted on the robot  and from
the sonars (if they exists) present in the robot working environment. </li>

<li><em>showSonarData</em>: show data coming forn the sonar-sensor  on a radar <tt>GUI</tt>:
<img src="./radarGui.png" alt="radarGui" width="10%" height="10%"/>
</li>
<li><em>handleConds</em>: allow the robot to <bc>stop</bc> its behavior under some specific condition, 
like for example an <b>alarm</b> emitted by some external entity, or when the <b>ambient temperature</b> overcomes a given limit value 
or when the robot <b>hits an obstacle</b>.
 </li>

</ol>
</div>

<div class="remark">
This system is intended to be a starting step towards the development of 
<a href="https://en.wikipedia.org/wiki/Internet_of_things" target="web">Internet of things</a>(<tt>IOT</tt>) applications.
See the section: <a href="#lab11iot">The Application Domain</a>
</div>


<h3 id="available">Resources already available</h3>
Besides the (open-source) software available from Internet, we can use software already developed by our company, and in particular:
<ul>
<li>A virtual environment (named <bc>WEnv</bc>) built in JavaScript, that includes a virtual robot that accepts commands 
sent on a<tt> TCP</tt> connection on port <tt>8999</tt>. 
See <a href="http://htmlpreview.github.com/?https://github.com/anatali/iss2019Lab/blob/master/it.unibo.robots19/userDocs/Lab9.html" target="lecture">Lab9.html</a> </li>
<li>A basic robot control software for physical ddr robots (<bc>BaseRobot</bc>), modeled as an  <tt>observable POJO</tt>.
See <a href="UsingRobots2019.pdf" target="lecture">UsingRobots2019.pdf sections 3 and 4</a>.</li>
<li>A software system written in Java that simulates the screen of a <bc>radar</bc>. 
The project  <tt>it.unibo.java.radar</tt> implements a software system able to display distance values on an output device 
that simulates the screen of a radar.  The deployment file is   <tt>radarPojo.jar</tt> .

 </li>
<!--  A IOT envelope (called mbot) of the BaseRobot that allows us to send commands on the network to a real
robot built upon a mBot robot.  -->
<!-- <li>A front-end system written in Node that provides a user interface and support for user-authentication.</li> -->
</ul>

<h3>Basic questions</h3>
Let us recall a set of basic questions that we can pose to ourselves at the starting of each new project.
<ul>
<li><em>Incremental development</em>: Is it possible to organize the production in terms of a <tt>sequence of systems</tt>, each facing a more wide/complex
set of requirements so that each system can be designed and built as the <bc>incremental evolution</bc> of the previous one?</li>
<li><em>Top-down or bottom up?</em>: What is our starting point? Do we start by what is already available (by following a <tt>bottom-up</tt> approach) or 
do we follow a <tt>top-down</tt> approach that first detects a logic architecture of the system and afterward selects
the technology? </li>
<!-- <li><em>Requirement sequencing</em>Is it possible to order the set of requirements into a list of increasing complexity and to harmonize such a list
with the <bc>product backlog</bc> defined by our <tt>product-owner</tt>? </li> -->
</ul>

Of course, we will - sooner or later - use as much as possible the (hopefully corrected or at least tested) software
that our company has already built in the <tt>IOT</tt> domain. The intent however is to avoid the a-priori introduction of
such a software. 
<!--Rather, our aim is to introduce proper available software libraries, infrastructures, components
etc. as the proper consequence of our problem analysis or of our design choices. -->
In other words: 

<div class="remark">
we will not start from any available software, with the intent to discover what are the most appropriate resources
able to satisfy our needs <bc>after the analysis</bc> of the requirements  and of the problem.
</div>

<!--
Model Driven methodology (GeneXus)
Describe: Create a technology-independant representation of the desired application.
Forward Engineering: The specific model can be discarded and regenerated at any time.
Extensible: There are clear options to extend the model, which enable the developer to extend the final application using the specific language.
DRY: There are no duplicated definitions of concepts (Don't Repeat Yourself).

https://wiki.analog.com/resources/eval/user-guides/eval-adicup3029/smart_app/android_app
-->

<h2><a id="Methodology"/>Methodology</h2> 
<img src="./Scrum-framework.jpg" alt="Scrum-framework" width="60%" height="60%"/>
<br/>
<img src="./overviewScrum.jpg" alt="overviewScrum" width="100%" height="30%"/>
<!--
<br/><img src="./scrum1.png" alt="scrum1" /> <br/>-->



<h3>Technology (in)dependency and modeling</h3>
In the first phase of our development, we want to be <em>technology-aware</em> but also as much technology-independent
as possible. To achieve such a goal, we will start by building a <em>conceptual model</em> of the system. From
<a href="https://en.wikipedia.org/wiki/Systems_modeling" target="code">https://en.wikipedia.org/wiki/Systems_modeling</a>
we read:
<div class="remark">
A model is a representation of a system, made of the composition of concepts which are used to help
people know, understand, or simulate a subject the model represents.
</div>

<h3>A Product Backlog</h3>
According to the <em>SCRUM</em> framework of software development, we will suppose that the product backlog defined
by the <tt>Product Owner</tt> allows us to satisfy the set of requirements in incremental way, by distinguishing among a
set of macro-steps. More precisely, we will follow a '<bc>zooming methodology</bc>' (see the video 
<a href="https://www.youtube.com/watch?v=0fKBhvDjuy0" target="web">Powers of Ten</a>):

<ol>
<li>The first step defines the main components of the logic architecture of the systems, by focusing on their
interaction. In this phase, the behavior of each component should be simply 'simulated' in order to reproduce a set of
interaction patterns, with the aim to introduce a proper set of initial (integration, functional) <bc>Test-Plans</bc>.</li>
<li>Refine the logical architecture defined in the previous step, by including code that satisfies the requirements
in more detailed way or that satisfies more functional requirements.
.</li>

</ol>

<h3><a id="logicalarch"/>Logical Architecture</h3>
For <em>logical architecture</em> we intend here a software architecture that is defined as consequence of the
requirement/problem analysis phase, in the attempt to focus our attention <bc>on the problem itself</bc>, rather than on some specific
technology. We say that, during problem analysis, we are technology aware but not technology dependent.
<br/><br/>
The logical architecture will be progressively 'zoomed' into a project architecture
and a proper implementation and deployment.
<br/><br/>
The incremental approach will lead us to define a sequence of (QActor) models, that can be used as the reference
point for a sequence of <tt>SCRUM</tt> <bc>sprint</bc>, followed by proper <bc>sprint-review</bc> and <bc>sprint-retrospective</bc>.


<h2><a id="reqanalysis"/>Requirement Analysis</h2> 

After the (several) meetings with the customer, we can say that:

<ol>
<li>Our software system is a <bc>distributed system</bc> composed by two main entities: a <em>console</em> running on a <em>consoleNode</em> 
that can be a PC or on a SmartDevice and a (real or virtual) <em>robot</em>, running on its own <em>robotNode</em>.</li>
<li>The robot is equipped with a sonar (<em>sonar-robot</em>) put in front of it. Other sensors are, at the moment, 
excluded for costs reason.</li>
<li>To understand (or formally define) what is the meaning of the term <bc>robot</bc>, we must read
 <a href="UsingRobots2019.pdf" target="lecture">UsingRobots2019.pdf</a>. </li>
<li>The software running on the <em>consoleNode</em>  must allow the end-user to control the robot with very simple commands
(e.g. <tt>w, a, s, d, h</tt>).</li>
<li>A <em>console</em> running on a Smart Device could be conceived as a Application or as user-GUI running into  <bc>Browser</bc>. </li>
<li>The software running on the <em>robotNode</em> must execute the commands sent by the <em>human-user</em> via the <em>console</em> and must
be sensible to a set of conditions. Let us name, from now on, such a set with the term <em>envConds</em>.</li>
<li>The <em>envConds</em> set is actually given only with reference to examples, i.e. it is not clearly defined. However, the given examples
suggest two different type of conditions:
	<ul>
	<li>conditions related the <b>world external</b> to the system, e.g. alarms and temperature;</li>
	<li>conditions that <b>arise form the work of the system</b> itself, e.g. fining an obstacle.</li>
	</ul>
</li>
<li>It is not clear whether the <em>radarGUI</em> is shown in the <em>console</em> or it is a different system. From 
<a href="#available">resources already available</a> we can assume that we can/should use the library <tt>radarPojo.jar</tt>.
</li>

</ol>

<h3><a id="firstModel"/>A first model of the system Architecture</h3>
At this stage, the system architecture can be represented as in the following, informal picture:

<center><table style="width:98%">
<tbody>	
<tr>
<td style="width:55%">
<img src="./robotRadarReq.png" alt="robotRadarReq" width="100%" height="30%"/>
<br/>
</td>
<td>
<m>
The structure of the <bc>information exchanged</bc> among the main components of the application is (at the moment) defined as follows:
<ul>
<li>from console to robot: <tt>robotCmd : robotCmd(X)</tt></li>
<li>from robot to radar: <tt>polar : p( Distance, Angle )</tt></li>
<li>from the environment: <tt>envCond : envCond(X)</tt></li>
</ul>

These definitions are very useful to assure interoperability, but they do not arise from the requirements; thus,
can be changed in the next models.
</m>
 
</td>
 </tr>
 </table>
</center>

<h3>A first model (towards<bc> Requirements traceability</bc>) </h3>
A better specification of the system architecture can be given by introducing a model written in a machine-understandable language. 
For example, a   
<a href="http://htmlpreview.github.com/?https://github.com/anatali/iss2019Lab/blob/master/it.unibo.qakactor/userDocs/LabQak.html" target="lecture">QActor</a>
specification allows us to introduce a description that associates each running component (actor) with the requirements 
(see <a href="https://en.wikipedia.org/wiki/Requirements_traceability" target="web">Requirements traceability</a>):

<pre>
------------------------------------------------------------------------------------------------------------------------------
System ddrworker
Event    envCond   : envCond( CONDTYPE )            //from the environment  
Event    sonar     : sonar(SONAR, DISTANCE)	        //from sonar in the robot environment   
Event    sonarRobot: sonar( DISTANCE )	            //from  sonar on robot 

Dispatch robotCmd  : robotCmd(X)	                //from console to robot
Dispatch polar     : p( Distance, Angle )           //from robot to radar

Context <ks>ctxRobotReq</ks> ip [host="localhost" port=8025]

<kc>//requirements: <ks>human user interaction, sendMoveCmds</ks></kc>
QActor <k>consolereq</k> context ctxRobotReq{ <kc>//Provides a user GUI and <k>Forwards <ks>robotCmd</ks> to robotplayerreq</k></kc> }        

<kc>//requirements: <ks>sendMoveCmds.move, handleConds, receiveSensorInfo, showSonarData</ks></kc>
QActor <k>robotreq</k> context ctxRobotReq{ <kc>/* Handles <ks>robotCmd</ks>, <ks>sonar</ks>  <ks>envCond</ks>;  
	                                                     moves the robot and <k>Forwards <ks>polar</ks> to radarreq</k></kc> */ }    

<kc>//requirements: <ks>showSonarData</ks></kc></kc>
QActor <k>radarreq</k> context ctxRobotReq{  <kc>//Uses <ks>radarPojo.jar</ks> to show sonar data</kc> }     
------------------------------------------------------------------------------------------------------------------------------
 </pre>

  <center><table style="width:98%">
<tbody>	
<tr>
<td style="width:60%">
<img src="./robotRadarReq1.png" alt="robotRadarReq1" width="95%" height="30%"/>
</td>
<td>
<m>
<li>The first prototype aims at capturing the <em>fundamental aspects</em> of the system we have to build.<br/></br></li>
<li>There is a <bc>single context</bc>, in order to just check  the logical interactions and to fix the main business logic.<br/></br></li>
<li>The <bc>business logic</bc> is almost entirely included in <tt>robotreq</tt> actor.</li>
 
</m>
 
</td>
 </tr>
 </table>
</center>

Note that in this first model:
<ul>
<li>The names of the actors ends with the suffix <bc>req</bc> to recall that they are part of the first model, related
to our requirement analysis. These names will change in our next model refinements.</li>
<li>The <em>responsibility</em> to satisfy the requirements is already <b>distributed among the actors</b>.</li>
<li>Data identified with the names <bc>userCmd</bc>, <bc>robotCmd</bc> and <bc>polar</bc> are defined as <em>Dispatches</em>.
In fact, from the requirements, we deduce that each of them has a specific destination.
</li>
<li>Data identified with the names <bc>envCond</bc> and <bc>sonar</bc> are defined each as <em>Events</em>.
In fact, <bc>envCond</bc> models information generated by the 'world' outside the system, while <bc>sonar</bc> is information
generated by the virtual robot. In both cases, the entity that generates this data cannot known the names of the actors
working in our system.</li>    
</ul> 

  
 

<h2><a id="problemanalysis"/>Problem analysis</h2> 
The main goal of problem analysis can be summarized as follows:
<ol>
<li>understand the (technical) problems posed by the requirements;</li>
<li>identify the best tools/libraries/supports etc. necessary and/or useful for building the system;</li>
<li>clarify the constraints  (human, technical, economical, etc.) related to both the software
<em> product</em> to build and the software <em>production process</em>;</li>
<li>define a <bc>logical architecture</bc> of the system and a <em>first working prototype</em> to show to the customer
at the end of our <em>first sprint</em>.
</li>
 
</ol>

In the context of <tt>SCRUM</tt>, one or more of these steps will be redone in the <em>sprint-review meetings</em>.

<br/><br/>
In our case, we can say that:
<ol>
<li>The system is distributed and <bc>effective operational supports</bc> are required. At the current state of the art, there are
several possible candidates, whose number is increasing. We will start from the support given by the <tt>QAk-infrastructure</tt>.
In a second moment, when the requirements and the consequent logic of the system will be more stable, we will discuss
how to introduce other, different supports, with particular reference to <tt>MQTT</tt> and <tt> Web</tt>.<br/><br/></li>



<li>The system requires a <tt>GUI</tt> for human-user interaction that can be created by the <bc>console</bc> component.
The <tt>GUI</tt> can be a built by reusing a <tt>POJO</tt> already available, with the addition of an adapter to send information
to the <bc>console</bc>. A possible adapter can be <a href="../src/resources/guiSupport.kt" target="code">guiSupport.kt</a>
that sends the dispatch:
<pre>
Dispatch <ks>userCmd : userCmd(X)</ks>		<kc>//with X = w | a | s | d | h</kc> 
</pre>
</li>

<li>The <bc>robot</bc> component represents the control part of the system. To make such a control independent form the
particular type of robot to move (<tt>virtual, real-mbot, real-nano</tt>, etc.) it is opportune to introduce a resource 
<a href="../src/resources/robotSupport.kt" target="code">robotSupport.kt</a> working as a robot-
<a href="https://en.wikipedia.org/wiki/Facade_pattern" target="web">facade</a>.
<!--
<br/></br>
From  <a href="UsingRobots2019.pdf" target="lecture">UsingRobots2019.pdf sections 3 and 4</a>, we discover that each robot type
'emit' sonar event with its own pattern. In particular:
<ul>
<li><em>mbot</em> sends over a TCP connection data of the form: </li>
<li></li>
</ul>
-->
<br/></br>
</li>

<li>The <bc>robot</bc> control must work as a <em>proactive/reactive</em> component, since it must execute user commands without
loosing the capability to react to <em>envCond</em> events and to update the radar. With reference to the  motto
<i>divide et impera</i>, it is opportune to distribute some responsibility by introducing another actor to handle 
<bc>sonar</bc> events and to interact with the radar:

<pre>
<kc>//requirements: <ks>sendMoveCmds.move, handleConds</ks></kc>
QActor <k>robotreq</k> context ctxRobotReq{ <kc>// Handles <ks>robotCmd</ks>, <ks>envCond</ks>; moves the robot }    

<kc>//requirements: <ks>receiveSensorInfo, showSonarData</ks></kc>
QActor <k>sonarhandler</k> context ctxRobotReq{  <kc>//Handles <ks>sonar</ks> and <k>Forwards <ks>polar</ks> to radarreq</k></kc> }    

</pre>

</li>
<li>The <bc>radar</bc> actor must show on the <tt>radar-GUI</tt> the sonar data enclosed in the dispatch <bc>polar : p( Distance, Angle )</bc>.
To this end, it can reuse the <tt>POJO</tt> facade given by the library <tt>radarPojo.jar</tt>:

<pre>
package radarPojo;
import it.unibo.radar.common.RadarControl;
public class radarSupport {
private  static RadarControl radarControl;

public static void <k>setUpRadarGui</k>( ) {
		try {
			radarControl = new RadarControl( null );
		} catch (Exception e) {
 			e.printStackTrace();
		}
	}
	public static void <k>update</k>(  String dist, String theta ){
		if( radarControl != null ) radarControl.update(   dist,   theta );
	}
}
</pre>
</li>

<li>The problem of a <em>GUI for a smart device</em> is not trivial, since the development of an Application requires
effort and probably introduces technology lock-in. On the other side, a browser-based implementation of the user-GUI 
requires the introduction of a Web infrastructure. Let us postpone this problem to a next sprint.</li>
</ol>


<h3>Logical architecture</h3>
With the help of the supports built  after the problem analysis phase, we can define in more detail the logical architecture of the system
and our first working prototype. Let us start from the declaration of the messages and events:

<pre>
Event    envCond   : envCond( CONDTYPE )            //from the environment (simulated)
Event    sonar     : sonar(SONAR, DISTANCE)	        //from sonar in the robot environment   
Event    sonarRobot: sonar( DISTANCE )	            //from  sonar on robot 

Dispatch userCmd   : userCmd(X)		                //from GUI to console
Dispatch robotCmd  : robotCmd(X)	                //from console to robot
Dispatch polar     : p( Distance, Angle )           //from robot to radar
</pre>


Let us start from the actor that captures our business logic.


<h4><a id=""/>The robot</h4> 
The principal actor of our system is a proactive/reactive component that executes user commands without
loosing the capability to react to <bc>envCond</bc> events:
<pre>
<k>QActor</k> robotreq <k>context</k> ctxRobotReq{   
	<k>State</k> s0 <k>initial</k> { <k>run</k> <ks>resources.robotSupport.create( myself, "virtual" )</ks>	}
	<k>Goto</k> waitCmd
	
	<k>State</k> waitCmd{ }
	<k>Transition</k> t0 <k>whenMsg</k>  robotCmd -> handleCmd
	             <k> whenEvent</k> envCond -> handleCond
	
	<k>State</k> handleCmd{
		<k>onMsg</k> ( robotCmd : robotCmd(CMD) ){	<k>run</k> <ks>resources.robotSupport.move( "msg(${payloadArg(0)})"  )</ks> }	
	}
	<k>Goto</k> waitCmd
	
	<k>State</k> handleCond{ <k>run</k> <ks>resources.robotSupport.move( "msg(stop)"  )</ks> }
	<k>Goto</k> waitCmd
}
</pre>

This version of the <bc>robot</bc> actor does not handle the event <em>sonar</em> emitted by the virtual robot.  This task is delegated
to the <bc>sonarhandler</bc> that <tt>forward</tt> the message  <em>polar</em> to the actor <bc>radar</bc> .

<h4><a id=""/>The sonarhandler</h4> 
  
<pre> 
	State waitForEvents{  }      
   	Transition t0 whenEvent sonar      ->  sendToRadar
   	              whenEvent sonarRobot ->  sendToRadar
   	               
 	State sendToRadar{                      
 		printCurrentMessage                                        
 		onMsg ( sonar  : sonar( SONAR, DISTANCE ) ){     
			[" val D = Integer.parseInt( payloadArg(1) ) * 5"] 
			forward radarreq -m polar : p( $D, 90  ) 
 		}
 		onMsg ( sonarRobot : sonar( DISTANCE ) ){     
			[" val D = Integer.parseInt( payloadArg(0) ) * 5"] 
			forward radarreq -m polar : p( $D, 180  ) 
 		}
 	} 
 	Goto waitForEvents
</pre>

The full code is in <a href="../src/robotWorker.qak" target="code">robotWorker.qak</a>.
 
 <h2><a id="Project"/>Project</h2> 
 Here we:
 <ol>
 <li>Provide the proper support for the different types of robots.</li>
 <li>Distribute the actors into proper different contexts. </li>
 <li>Test the system on the network.</li>
 <li>Substitute the  <tt>QAk-infrastructure</tt> with a <tt>MQTT</tt> support.</li>
 <li>Define a better <tt>GUI</tt> and/or a <tt>GUI</tt> for a <bc>smart device</bc>. </li>
 <li>Refactor the <bc>robot</bc> control according to the MVC design pattern.</li>
 </ol>
<!--

<h3><a id=""/>Project Architecture</h3>
<center><table style="width:98%">
<tbody>	
<tr>
<td style="width:55%">
<img src="./robotRadar0.png" alt="robotRadar0" width="100%" height="30%"/>
 
</td>
<td>
<m>
<ul>
<li>Frontend Model: <a href="../src/frontend.qak" target="code">frontend.qak</a></li>
<li>Robot Model: <a href="../src/robotWorker.qak" target="code">robotWorker.qak</a></li>
<li>Radar Model: <a href="../src/radar.qak" target="code">radar.qak</a></li>
</ul>
</m>
</td>
 </tr>
 
 <tr>
<td>
<img src="./robotWorker.png" alt="robotWorker" width="100%" height="30%"/>
 
</td>
<td>
<m>
Robot Model: <a href="../src/robotWorker.qak" target="code">robotWorker.qak</a>
<ul>
<li><bc>player</bc>:  handles <tt>robotCmd</tt> to move the robot and sends <tt>usercmd</tt> to <bc>mind</bc>
for the application logic.</li>
<li><bc>mind</bc>: executes the robot work (application logic) by sending <tt>robotCmd</tt> to <bc>player</bc> </li>
<li>sonarhandler: handles  <tt>sonar</tt> and sends <tt>polat</tt> to <bc>radar</bc>.  </li>
</ul>
</m>
</td>
 </tr>
 
 
</table>
</center>
 
<h2><a id="lab11iot"/>The Application Domain</h2> 

<img src="./iot3.png" alt="iot0" width="100%" height="100%"/>

<img src="./iot0.png" alt="iot0" width="70%" height="70%"/>
<img src="./iotRobot.png" alt="iotRobot" width="60%" height="60%"/>

-->


</div>
<div style="background-color:rgba(86, 56, 253, 0.9); width:100%;text-align:center;font-size:small;color:white">
By AN Unibo-DISI    
</div> 
</body>
</html>