<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
<!--

body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin: 10;
    margin-right: 15px;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
    border-bottom: 1px solid #242424;
}

h1 {
    font-size: 150%;
    background-color: #b2c0ff;
}

h2 {
    background-color: #d9fbff;
    font-size: 110%;
}

h3 {
	background-color: #e6ccff;
    font-size: 80%;
}
h4 {
    background-color: #99ffcc;
    font-size: 100%;
	width: 750px;
}
#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 80%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #ccffff;
    color: #0033cc;
}
bc{
	font-family: "Arial";
	font-size: 80%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
pre{
	font-family: "Helvetica";
	font-size: 80%;
	background-color: #fcf8c7; 
}
 
m{
	font-family: "Helvetica";
 	font-size: 80%;
}
div.body{
	width: 800px;
    font-size: 18px;
}    
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}    

table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}

  -->
</style>
    
<head>
   
<title>ISSLAB2019</title></head>
    
<body>

<div class="body"> 

<h1>72939 - LAB4 | Introduction to KOTLIN</h1> 
<a href="http://infolab.ingce.unibo.it/iss2018/it.unibo.issMaterial/issdocs/Material/LectureBologna1819.html" target="isslm">LabSS-lectures site</a></font> 

<br/><br/>
To run the experiments, use an IDE or <a href="https://play.kotlinlang.org">Kotlin Playground</a>.

You can consult also:

<a href="https://try.kotlinlang.org/#/Examples" target="web">Kotlin online</a>
 
<h2>INDEX</h2>

<ol>
<li><a href="#data">Data, Types and Variables</a></li>
<li><a href="#funs">Functions</a></li>
<li><a href="#clos">Closures</a></li>
<li><a href="#suspend">Suspending functions and coroutines</a></li>
<li><a href="#channels">Channels</a></li>
<li></li>
<li></li>
<li></li>
<li></li>
 
</ol>

<h2><a id="basics"/>BASICS</h2>
 

<h3><a id="data"/>Data, Types and Variables</h3>

<center><table style="width:95%">

<tbody>	
<tr>
<td style="width:45%"><pre> val counter : Int = 0</pre> </td>
<td><m><em>Immutable reference</em>. </m> </td>
</tr>

<tr>
<td><pre>var counter = 0</pre> </td>
<td><m><em>Mutable reference</em>. The Type <bc>Int</bc> is inferred</m> </td>
</tr>

<tr>
<td><pre>val name = "Bob"
val str = "Hello $name"
println( str )	//Hello Bob
</pre> </td>
<td><m><em>String template</em></m> </td>
</tr>


<tr>
<td><pre>val name : String? = null
val v = name?.length ?: 0
println("v=$v")	//0
</pre> </td>
<td><m><em>Nullable type</em> with safe null access</m> </td>
</tr>
<tr>
<td><pre>
val v : Any = 23
println( "v is String=${v is String}") //true
println( "v is Int=${v is Int}")	//false
</pre> </td>
<td><m><em>Type hierarchy</em>. <bc>Any</bc> is is a non-nullable type that denotes the root of the Kotlin class hierarchy. 
<bc>Unit</bc> is used as a return type of a function that has nothing to return
</m> </td>
</tr>


<tr>
<td><pre>var v : Any = "Bob"
println( "v is String=${v is String}") //true
println( "v is Int=${v is Int}")	//false
</pre> </td>
<td><m><em>Smart cast</em>. <bc>is</bc> is a predefined check operator (like Java <bc>instanceOf</bc>)</m> 
</td>
</tr>

<tr>
<td><pre>val v : Any = "Bob"
//val n = v.length //ERROR
val n = (v as String).length
println( "$n") //3
//println( "${v as Int}") //java.lang.ClassCastException
println( "${v as? Int}")  //null

val t : Int = v as? Int ?: 100
println( "$t") //100  //100
</pre> </td>
<td><m><em>Explicit casting</em>. The <bc>as</bc> operator performs type casting. 
The <bc>as?</bc> operator performs safe type casting
The <bc>?:</bc> is the <em>Elvis operator</em> that provides default values instead of null
</m> </td>
</tr>

<tr>
<td ><pre>
val s1 = "a"
var s2 = "a"
println( "s1 === s2 : ${s1 === s2} ") //true
println( "s1 == s2  : ${s1 == s2} ") //true

s2 = "b"
println( "s1 === s2 : ${s1 === s2} ") //false
s2 = "a"
println( "s1 === s2 : ${s1 === s2} ") //true

val a = java.io.File("a")
val b = java.io.File("a")
println( "a === b : ${a === b}") //false
println( "a == b  : ${a == b}") //true

</pre> </td>
<td><m><em>Referential equality</em> <bc>===</bc> and </m> <em>structural equality</em> <bc>==</bc> 
(that is translated into a call of the <bc>equals</bc> function of the class) </td>
</tr>

<tr>
<td><pre> 
val aToz = "a".."z"
val q = "q"
println( "q in aToz=${q in aToz}") //true
println( "1 in aToz=${"""1""" in aToz}") //false
</pre> </td>
<td><m><em>Range</em> created by the <bc>..</bc> operator.
The <bc>in</bc> infix operator performs a belong test. Triple quotes <bc>"""</bc> do not require escaping chars</m></td>
</tr>

<tr>
<td><pre>var a = arrayOf(1,2,3)
println( "array of size=${a.size}")
println( "firstEl=${a[0]}  lastEl=${a[a.size-1]}")
</pre> </td>
<td><m><em>Array</em>. They are a regular collection class. <bc>size</bc> is a <em>Property</em></m> </td>
</tr>


</tbody>	
</table></center>
 	

<h3><a id="funs"/>Functions</h3>

<center><table style="width:95%">
<tbody>	
<tr>
<td style="width:45%"><pre>fun sum(a:Int, b:Int) : Int {
  return a+b
}
println( " ${sum(3,6)} " ) //9
</pre> </td>
<td><m>A <em>Top-level function</em> that returns a value</m>
 </td>
</tr>

<tr>
<td><pre>var counter = 0
fun incCounter() : Unit{ counter++ }
fun decCounter() { counter-- }

println( "pre=$counter  " ) //pre=0
incCounter()
println( "post=$counter " ) //post=1
decCounter()
</pre> </td>
<td><m>Top-level functions that <em>do not return a value</em>. The return type <bc>Unit</bc> can be omitted</m></td>
</tr>

<tr>

<tr>
<td><pre>fun square(v: Int) = v * v
println( " ${square(3)} " ) //9
</pre> </td>
<td><m><em>One line function</em>. Braces can be omitted. Return type can be omitted (it is inferred)</m> </td>
</tr>






<td><pre>
val action : () -> Unit 	   
	//function type (no args, returns nothing useful (Unit)

val sum : ( Int,  Int) -> Int  
	//function type (two args, returns an Int)

val greet: ( String )-> ()->Unit
	//returns another function  
</td>
<td><m><em>Function type</em> is just a syntactic sugar for an interface, but the interface cannot be used explicitly.
We can  use them to type local variables, properties or arguments.
It is implemented in Java as a <bc>FunctionN</bc> interface.

A  way to provide a value function is to use a <em>function literal</em>:

<ul>
<li><em>Lambda expression</em></li>
<li><em>Anonymous function</em></li>

</ul>
</m> </td>
</tr>

<tr>
<td><pre>
action	= { println("hello") }  //lambda expression
action() //hello

sum = { x:Int, y:Int -> x+y }  //lambda expression
val a = sum(1,2)
println("a=$a")	      //a=3

greet = { m: String -> { println(m)}  }
greet( "Hello World" )() //Hello World

---------------------------------------------------
{ println( "Welcome" ) }()  //Welcome

val fl = { print( "Last exp val=" ); 100 }
println( "${fl()}" )  //Last exp val=100
</td>
<td><m><em>Lambda Expression literal</em>: it can be assigned to a variable, just like any other literal. 
Returns (the value of the) <bc>last</bc> expression </m> </td>
</tr>

<tr>
<td><pre>
val action: ()->Unit = fun() { println("Hello") }
action() //hello

val sum: (Int)->Int  = fun(x) = x * x
println("sum=${sum(1,2)}")	      //sum=3

val greet: (String)->()->Unit = 
		fun(m:String) = fun() { println("Printing $m") }
greet( "Hello World" )() //Printing Hello World

------------------------------------------
fun exec23( op: ( Int, Int) -> Int ) {  op(2,3)  }

val v4 =  exec23( fun(x:Int,y:Int):Int{return x+y} )
println("$v4")          //5
</pre> </td>
<td><m><em>Anonymous function</em>; another way to write a block of code instead of a Lambda expression. Needs <bc>return</bc>
like any function </m> </td>
</tr>

<tr>
<td><pre>
fun exec23( op:(Int,Int) -> Int ) : Int { return op(2,3) }

val sum = { x:Int, y:Int -> x+y }
val mul = { x:Int, y:Int -> x*y }

println("${ exec23(sum) }")	      //5 
println("${ exec23(mul) }")	      //6

</td>
<td><m><em>Higher order functions</em>. </m> </td>
</tr>



<tr>
<td><pre>
fun exec23( op:(Int,Int) -> Int ) : Int { return op(2,3) }

val v1 = exec23( { x:Int, y:Int -> x-y } ) //no shortcut
println("v1=$v1")	      //v1=-1

val v2 = exec23() { x:Int, y:Int -> x-y } //lamda is last arg
println("v2=$v2")	      //v2=-1

val v3 = exec23{ x:Int, y:Int -> x-y } //() can be removed
println("v3=$v3")	      //v3=-1

val v4 = exec23{ x,y -> x-y } //arg types inferred
println("v4=$v4")	      //v4=-1

	
</td>
<td><m><em>Lambda syntax shortcut</em>. </m> </td>
</tr>

<tr>
<td><pre>
fun p2( op: ( Int ) -> Int ) : Int { return op(2) }

    val v1 = p2( { x:Int-> x*x } )
    val v2 = p2( )  { x:Int-> x*x }
    val v3 =  p2 { x:Int-> x*x }
    val v4 =  p2 { x -> x*x }
    val v5 =  p2 { it -> it*it }
    println("v5=$v5")	      //v45=4
</pre> </td>
<td><m><em>Simplifcation</em> </m>. The keyword <bc>it</bc> is an auto-generated parameter name </td>
</tr>



<td><pre>
fun modulo(k:Int): (Int) -> Int    //SIGNATURE
            = { it % k  }               //BODY
var v = modulo(3)(5)	
println("$v") //2
</pre> </td>
<td><m><em>Function as return value</em>.  </m> </td>
</tr>




<tr>
<td><pre>
</pre> </td>
<td><m><em>...</em></m> </td>
</tr>

<tr>
<td><pre>
fun sToN( s: String, base: Int=10 ) : Int{
    var v = 0
    for( i in 0..s.length-1 ) {
        v = ( s[i].toInt()-48 ) + v*base
    }
    return v
}

println( " ${ sToN( s: "123") } " ) //123
</pre> </td>
<td><m><em>Default parameters</em> with <em>Named parameters</em> at call </m> </td>
</tr>




<tr>
<td><pre>fun mirror(v: Int) : Pair<Int,Int> {
	return Pair(v, -v)
}

val(pos,neg) = mirror(3)
println( " pos=$pos neg=$neg " ) //pos=3 neg=-3  
</pre> </td>
<td><m><em>Multiple return values</em>. To extract the values into separate values, we can exploit
<bc>destructuring declarations</bc> (syntactic sugar)</m> </td>
</tr>



<td><pre>fun sum(a:Int, b:Int) : Int {
  return a+b
}
println("${::sum}") //fun sum(kotlin.Int,kotlin.Int):kotlin.Int 
</pre> 
To obtain the output, include the dependency on:
<pre>
implementation "org.jetbrains.kotlin:kotlin-reflect"
</pre>
</td>
<td><m><em>Function reference</em>. The <bc>::</bc> operator creates a member reference or a (statically known) class reference.
The <em>reference</em> is a value of type <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html" target="web">KClass</a>.
A Kotlin class reference is not the same as a Java class reference. To obtain a Java class reference, 
use the <bc>.java</bc> property on a <tt>KClass</tt> instance.</m>
 </td>
 
</tbody>	
</table></center>
 

 <h3><a id="clos"/>Closures</h3>

<center><table style="width:95%">
<tbody>	
<tr>
<td style="width:45%"><pre>
fun counterCreate()  : ( cmd : String ) -> Int {
    var localCounter = 0
    return {
        when (it) {
            "inc" -> ++localCounter
            "dec" -> --localCounter
            "val" -> localCounter
             else -> throw Exception( "unknown" )
        }
    }
}

val c1 = counterCreate()
for( i in 1..3 ) c1("inc")
println("c1=${c1("val")}")	      //c1=3

val c2 = counterCreate()
for( i in 1..3 ) c2("dec")
println("c2=${c2("val")}")	     //c2=-3

</pre> </td>
<td><m>The <em>closure</em> returned by <bc>counterCreate</bc> is "closed over" the variable <bc>localCounter</bc>.
We are reproducing oo programming style (<i>instance</i> and <i>state encapsulation</i>)</m> </td>
</tr>

<tr>
<td><pre>
suspend fun inputFun( callBack : ( String ) -> Unit){
 println("Performing an input operation ...")
 kotlinx.coroutines.delay(500)
 println("Call the callback")
 callBack("someInput")
}

fun main() = runBlocking{
    println("BEGINS")
    launch{ inputFun( {  println( "$it" )}) }
    println("ENDS")
}

//OUTPUT
BEGINS
ENDS
Performing an input operation ...
Calling the callback
someInput
</pre> </td>
<td><m><em>Callbacks</em> are quite common in event-loop architectures such as JavaScript.
People have moved away to using other approaches such as promises or 
Reactive Extensions (Rx) (<tt>C#</tt>, <tt>.NET</tt>).</m> 

asynchronous programming 
</td>
</tr>

<tr>
<td><pre>
fun getInput() : String{
    println("Input  ...")
    return "myinput"
}
fun submit( v: Int, msg: String ) : String{
    println("Submit ...")
    return "$msg-$v"
}
fun handle( msg: String ){
    println("Handle $msg")
}
fun doJob(n:Int){
    val s = getInput()
    val v = submit( n, s )
    handle( v )
}
fun main() = runBlocking{
    println("BEGINS")
    doJob(10)
    println("ENDS")
}

//OUPUT
BEGINS
Input  ...
Submit ...
Handle myinput-10
ENDS
</pre> </td>
<td><m><em>Normal sequence</em></m> </td>
</tr>


<tr>
<td><pre>
fun doJobCps( n: Int, callback : ( String ) -> Unit ){
    val s = getInput()
    callback( s   )
}
fun submitCps( v: Int, msg: String , callback : ( String ) -> Unit )  {
    println("Submit ...")
    callback( "$msg-$v" )
}
fun main() = runBlocking{
    println("BEGINS")
    val n = 10
    doJobCps( n, {  t -> submitCps( n, t , { m -> handle(m) } )  } )
    println("ENDS")
}

//OUPUT
BEGINS
Input  ...
Submit ...
Handle myinput-10
ENDS
</pre> </td>
<td><m><em>Continuation-passing style</em></m> see <a href="https://en.wikipedia.org/wiki/Continuation-passing_style">CPS</a>.
Should be asynchronous</td>
</tr>




</tbody>	
</table></center>

<h3><a id="suspend"/>Suspending functions and coroutines</h3>

<center><table style="width:95%">
<tbody>	
<tr>
<td style="width:45%"><pre>
suspend fun ioBoundFun(){
	val timeElapsed = measureTimeMillis {
		println("Performing an IO operation ...")
		kotlinx.coroutines.delay(500)
	}
	println("Done, time=$timeElapsed")
}

fun main() = runBlocking{
    println("BEGINS")
    ioBoundFun()
    println("ENDS")
}

//OUTPUT:
BEGINS
Performing an IO operation ...
Done, time=527
ENDS
</pre> </td>
<td><m>A function that can <em>susped</em> its work cannot be called from a normal function,
but only from another suspend function or from a <em>Coroutine</em>, created with a <em>Coroutine Builder</em>:
<ul>
<li><bc>GlobalScope.launch</bc> | <bc>launch</bc> ! <bc>asynch</bc></li>
<li><bc>GlobalScope.actor</bc></li>
</ul>

The <tt>Coroutine Builder</tt> <bc>runBlocking</bc> is a wrapper that runs new coroutine and blocks current thread interruptibly until its completion. 
This function is designed to bridge regular blocking code to libraries that are written in suspending style, 
to be used in main functions and in tests.

<br/><br/>
Coroutines do not rely on features of the Operating System or the J<tt>VM</tt>. Instead, a <bc>Continuation</bc> is added to every suspending function as 
an additional parameter acording to the <em>Continuation-passing</em> style. The compiler produces a <em>state machine</em> to handle suspnesion.

</m> </td>
</tr>
 
 
 <tr>
<td><pre>
fun main() = runBlocking{
    println("BEGINS")
    val job = GlobalScope.launch {
        ioBoundFun()
    }
    println("ENDS")
}

//OUTPUT:
BEGINS
ENDS
Performing an IO operation ...
</pre> </td>
<td><m><bc>GlobalScope.launch</bc> launches an inner coroutine that works 'in parallel'. We do not await for coroutine completion
and the programs ends before that the coroutine is done
</m> </td>
</tr>
 
 
<tr>
<td><pre>
fun main() = runBlocking{
    println("BEGINS")
    val job = GlobalScope.launch {
        ioBoundFun()
    }
	job.join()
    println("ENDS")
}

//OUTPUT:
BEGINS
Performing an IO operation ...
Done, time=524
ENDS
</pre> </td>
<td><m>Coroutines started by <bc>launch</bc> return a  <em>Job</em> immediately, which we can use to <tt>cancel</tt> 
the computation or <em>await</em> its completion with <bc>join</bc></m> </td>
</tr>


<tr>
<td><pre>
fun main() = runBlocking{
    println("BEGINS")
    val job = launch {
        ioBoundFun()
    }
    //job.join()
    println("ENDS")
}

//OUTPUT
BEGINS
ENDS
Performing an IO operation ...
Done, time=550
</pre> </td>
<td><m>If we change <bc>GlobalScope.launch</bc> to just <bc>launch</bc>, then the coroutine is launched in the
scope of the outer <bc>runBlocking</bc> coroutine.
As a result, we can now also remove the explicit <bc>join</bc> since <tt>runBlocking</tt> won't complete before all of its 
child coroutines finish.

This is an example of  <em>structured concurrency</em></m>: coroutines confined to different scopes 
are more maintainable and manageable. </td>
</tr>

<tr>
<td><pre>
suspend fun activate(){
    val job1 = GlobalScope.async{
        ioBoundFun()
    }
    val job2 = GlobalScope.async{
         ioBoundFun()
    }
    println("Waiting for completion")
    val end1 = job1.await()
    val end2 = job2.await()
    println("All jobs done")
}

fun main() = runBlocking{
    println("BEGINS")
    activate()
    println("ENDS")
}

//OUTPUT
BEGINS
Waiting for completion
Performing an IO operation ...
Performing an IO operation ...
Done, time=530
Done, time=546
All jobs done
ENDS
</pre> </td>
<td><m>The <bc>async</bc> builder returns a <em>promise</em> (also known as <tt>future</tt> ), 
(which is of type <bc>Deferred</bc> in Kotlin) that provides the method <bc>await</bc>: it promises to compute a value which we can wait for or 
request at any time</m> </td>
</tr>

<tr>
<td><pre>
fun main() = runBlocking<Unit> {
 println("BEGINS")
 launch { //context of the parent runBlocking  
  println("1) thread=${Thread.currentThread().name}")
 }
 launch(Dispatchers.Unconfined) { // in main thread
  println("2) thread=${Thread.currentThread().name}")
 }
 launch(Dispatchers.Default) { // DefaultDispatcher
  println("3) thread=${Thread.currentThread().name}")
 }
 launch(
  newSingleThreadContext("MyThr")) { //new thread
  println("4) thread=${Thread.currentThread().name}")
 }
 println("ENDS")
}

//OUTPUT
BEGINS
2) thread=main
3) thread=DefaultDispatcher-worker-1
ENDS
4) thread=MyThr
1) thread=main
</pre> </td>
<td><m><em>Coroutine Context</em>: a set of rules and configurations that define how the coroutine will be executed.
Useful to read: <a href="https://proandroiddev.com/demystifying-coroutinecontext-1ce5b68407ad" target="web">Demystifying CoroutineContext</a>
<br/><br/>
All the <em>coroutine builder</em> functions like <bc>launch</bc> and <bc>async</bc> have as first parameter a <tt>context: CoroutineContext</tt>
that can be used to specify context elements.
It includes a <em>CoroutineDispatcher</em> that determines 
the thread or threads where the coroutine will be executed. This dispatcher can be provided in two ways:

<ul>
<li><bc>Explicitly</bc>: the coroutine builder receives a coroutine context as a first parameter</li>
<li><bc>By the coroutine scope</bc></li>
</ul>



Every coroutine builder is also an extension on <em>CoroutineScope</em> interface and inherits its abstract read-only property
<tt>coroutineContext: CoroutineContext</tt> to  automatically propagate both context elements and cancellation.
See <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html" target="web">
Coroutine Scope</a>
 


<ul>
<li><bc>Global scope</bc>: the coroutine affects the whole Application</li>
<li><bc>CoroutineScope</bc>: defines a scope for new coroutines</li>
</ul>

-Dkotlinx.coroutines.debug JVM option
https://play.kotlinlang.org
/koans/overview

</m> </td>
</tr>

<tr>
<td><pre>
suspend fun launchAction(i:Int,scope:CoroutineScope){
	...
}
fun main() = runBlocking {
 val cpus = Runtime.getRuntime().availableProcessors();
 println("AT START | 
    CPU=$cpus threads=${Thread.activeCount()} 
    curThread=${Thread.currentThread().name}")
 println("BEGINS")
 for (i in 1..6) launchAction(i,this) 
 println("ENDS")
}</pre> </td>
<td><m><em>Code pattern</em> for experiments on Dispatchers:
<ul>
<li>Coroutine dispatcher can confine coroutine execution to a specific thread, dispatch it to a thread pool, 
or let it run unconfined.</li>
<li>Coroutines can be executed concurrently using a multi-threaded dispatcher.</li>
<li>Coroutines can suspend on one thread and resume on another thread.</li>
</ul>

We have four main Dispatchers:

<ol>
<li><bc>Default</bc>: for CPU-intensive tasks. It can use as many threads as CPU cores</li>
<li><bc>IO</bc>: IO-intensive tasks  waiting for an answer from another system. 
The size of this thread pool is 64</li>
<li><bc>Unconfined</bc>: don’t use it unless you’re very sure of what you’re doing</li>
<li><bc>Main</bc>: a special dispatcher that is included in <tt>UI</tt> related coroutine libraries
(see <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html" target="web">kotlinx.coroutines.Main</a>)</li>

</ol>
</m> </td>
</tr>


<tr>
<td><pre>
suspend fun launchAction(i:Int,scope:CoroutineScope){
	launchDefault(i,scope)
}
suspend fun launchDefault(i:Int,scope:CoroutineScope){
    scope.launch( Dispatchers.Default ){ action(i) }
}

//OUTPUT
AT START | CPU=4 threads=2 curThread=main
BEGINS
1) thread=DefaultDispatcher-worker-1
2) thread=DefaultDispatcher-worker-2
ENDS
3) thread=DefaultDispatcher-worker-4
4) thread=DefaultDispatcher-worker-3
6) thread=DefaultDispatcher-worker-1
5) thread=DefaultDispatcher-worker-4
Action 3 done
Action 1 done
Action 6 done
Action 5 done
Action 4 done
Action 2 done
</pre> </td>
<td><m><em>Dispatch.Default</em>: the actions are executed by as many Threads as the CPU cores
 
</m> </td>
</tr>

<tr>
<td><pre>
suspend fun launchAction(i:Int,scope:CoroutineScope){
	launchIO(i,scope)
}
suspend fun launchIO(i:Int,scope:CoroutineScope){
    scope.launch( Dispatchers.IO ){ action(i) }
}

//OUTPUT
AT START | CPU=4 threads=2 curThread=main
BEGINS
1) thread=DefaultDispatcher-worker-1
ENDS
2) thread=DefaultDispatcher-worker-2
3) thread=DefaultDispatcher-worker-3
4) thread=DefaultDispatcher-worker-4
5) thread=DefaultDispatcher-worker-5
6) thread=DefaultDispatcher-worker-6
Action 6 done
Action 2 done
Action 5 done
Action 3 done
Action 4 done
Action 1 done
</pre> </td>
<td><m><em>Dispatch.IO</em>: the actions are executed by a pool of (<tt>64??</tt>) Threads 
 
</m> </td>
</tr>

<tr>
<td><pre>
val th = newSingleThreadContext("My Thread")

suspend fun launchAction(i:Int,scope:CoroutineScope){
	launchSingle(i,scope)
}
suspend fun launchSingle(i:Int,scope:CoroutineScope){
    scope.launch( th ){ action(i) }
}

//OUTPUT
AT START | CPU=4 threads=2 curThread=main
BEGINS
1) thread=My Thread
ENDS
2) thread=My Thread
3) thread=My Thread
4) thread=My Thread
5) thread=My Thread
6) thread=My Thread
Action 1 done
Action 2 done
Action 3 done
Action 4 done
Action 5 done
Action 6 done
</pre> </td>
<td><m><em>Thread confinement </em>: : the actions are executed one a e time (in <tt>mutual exclusion</tt>)
by a <bc>single thread</bc>
 
</m> </td>
</tr>

<tr>
<td><pre>
suspend fun actionWithContext( n: Int){
 withContext(Dispatchers.Default) {
   println("$n) thread=${Thread.currentThread().name}")  
   delay(1000)
   println("ActionWithContext $n done")
 }
}
fun main() = runBlocking{
	println("BEGINS")
    for(i in 1..3) launch{ actionWithContext(i) } 
    println("ENDS")
}

//OUPUT
BEGINS
ENDS
1) thread=DefaultDispatcher-worker-1
2) thread=DefaultDispatcher-worker-2
3) thread=DefaultDispatcher-worker-3
ActionWithContext 3 done
ActionWithContext 1 done
ActionWithContext 2 done
</pre> </td>
<td><m><em>withContext</em>: allows to 
change the context that will be used to run a part of the code inside a coroutine.

 
</m> </td>
</tr>

<tr>
<td><pre></pre> </td>
<td><m><em>...</em>

 
</m> </td>
</tr>


</tbody>	
</table></center>

<h3><a id="channels"/>Channels</h3>

<center><table style="width:95%">
<tbody>	
<tr>
<td style="width:45%"><pre>
suspend fun channelTest(){
 val timeElapsed = measureTimeMillis {
     val n = 5
     val channel = Channel<Int>(2)

     val sender = GlobalScope.launch {
         repeat( n ) {
             channel.send(it)
             println("SENDER | sent $it")
         }
     }
     delay(500) //The receiver starts after a while ...
     val receiver = GlobalScope.launch {
         for( i in 1..n ) {
             val v = channel.receive()
             println("RECEIVER | receives $v")
         }
     }

     delay(3000)
 }
    println("Done. time=$timeElapsed")
}

//OUTPUT
BEGINS
SENDER | sent 0
SENDER | sent 1
RECEIVER | receives 0
SENDER | sent 2
SENDER | sent 3
RECEIVER | receives 1
RECEIVER | receives 2
RECEIVER | receives 3
RECEIVER | receives 4
SENDER | sent 4
Done. time=3556
ENDS
</pre> </td>
<td><m>Channels provide a way to transfer a <tt>stream of values</tt>. <bc>send</bc> and <bc> receive</bc>  are
<em>suspending functions</em> used for providing and consuming objects from the channel, implemented with a <tt>FIFO</tt>
strategy.

<br/><br/>
The example shows the usage of sn <bc>ArrayChannel</bc> of capacity <tt>2</tt>. The sender is suspended when the channel is full
and resumes as soon as the receiver consumes the data. This concept i often referred to as <em>Backpressure</em> and helps to
prevent a channel from being flooded with more elements than the receivers can actually process.

<br/><br/>
Kotlin defines several types of channels:

<br/><br/>
<em>Unbuffered Channels</em>:
<ul>
 
<li><bc>RendezvousChannel</bc> (the buffer has capacity <tt>0</tt> and the sender suspends until the element is cosnumed)</li>
</ul>

<em>Buffered Channels</em>:
<ul>
<li><bc>LinkedListChannel</bc></li>
<li><bc>ArrayChannel</bc></li>
<li><bc>ConflatedChannel</bc> (the buffer has capacity <tt>1</tt> and the sender overrides an element not cosumed)</li>
</ul>

</m> </td>
</tr>

<tr>
<td><pre></pre> </td>
<td><m><em></em></m> </td>
</tr>

<tr>
<td><pre></pre> </td>
<td><m><em> </em></m> </td>
</tr>

</tbody>	
</table></center>

 
<h3><a id="actors"/>Actors</h3>

<center><table style="width:95%">
<tbody>	
<tr>
<td style="width:45%"> <pre>
class CounterMsg( 
	val cmd : String , val replyChannel : SendChannel<Int>? = null){
}

fun counterActor() = GlobalScope.actor<CounterMsg> { //(1)
    var localCounter  = 0
    for (msg in channel) { // handle incoming messages
        when ( msg.cmd ) {
            "INC" -> localCounter++
            "DEC" -> localCounter--
            "GET" -> msg.replyChannel?.send(localCounter)
            else -> throw Exception( "unknown" )
        }
    }
}

suspend fun useTheCounter(){
    val counter = counterActor()
    println("INC")
    counter.send( CounterMsg("INC") )

    val answerChannel = Channel<Int>()
    counter.send( CounterMsg("GET", answerChannel) )

    val answer = answerChannel.receive()
    println("useTheCounter COUNTER = $answer")
}

fun main() = runBlocking{
    println("BEGINS")
    useTheCounter()
    println("ENDS")
}

//OUTPUT
BEGINS
INC
useTheCounter COUNTER = 1
ENDS
</pre> </td>
<td><m>An <em>Actor </em> :
<ul>
<li>confines the access of a state to a single Thread</li>
<li>modifies the state by using a channel</li>
</ul>

This combination of mechanisms open thw way to the concpet of <em>state share by communication</em>.

<br/><br/>
By default, an actor is <bc>unbuffered</bc>.
</m> </td>
</tr>

<tr>
<td><pre></pre> </td>
<td><m><em> </em></m> </td>
</tr>

</tbody>	
</table></center>

<h3><a id=" "/>Next</h3>

<center><table style="width:95%">
<tbody>	
<tr>
<td style="width:45%"> <pre></pre> </td>
<td><m><em> </em></m> </td>
</tr>

<tr>
<td><pre></pre> </td>
<td><m><em> </em></m> </td>
</tr>

</tbody>	
</table></center>

 
<br/><br/> 
</div>  

</body>
</html>