<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
<!--

body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin: 10;
    margin-right: 15px;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
    border-bottom: 1px solid #242424;
}

h1 {
    font-size: 150%;
    background-color: #b2c0ff;
}

h2 {
    background-color: #d9fbff;
    font-size: 110%;
}

h3 {
	background-color: #e6ccff;
    font-size: 80%;
}
h4 {
    background-color: #99ffcc;
    font-size: 100%;
	width: 750px;
}
#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 80%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #ccffff;
    color: #0033cc;
}
bc{
	font-family: "Arial";
	font-size: 80%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
pre{
	font-family: "Helvetica";
	font-size: 70%;
	background-color: #fcf8c7; 
}
 
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	width: 800px;
    font-size: 18px;
}    
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}    

table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}

  -->
</style>
    
<head>
   
<title>ISSLAB4</title></head>
    
<body>

<div class="body"> 

<h1>72939 - LAB4 | Introduction to KOTLIN</h1> 
<a href="http://infolab.ingce.unibo.it/iss2018/it.unibo.issMaterial/issdocs/Material/LectureBologna1819.html" target="isslm">LabSS-lectures site</a></font> 

<br/><br/>
To run the experiments, use an IDE or <a href="https://play.kotlinlang.org">Kotlin Playground</a>.

You can consult also:

<a href="https://try.kotlinlang.org/#/Examples" target="web">Kotlin online</a>
<br/> <br/> 
 <table style="width:95%">
<tbody>	
<tr>
<td style="width:55%">
<h3>INDEX</h3>

<ol>
<li><a href="#data">Data, Types and Variables</a></li>
<li><a href="#funs">Functions</a></li>
<li><a href="#clos">Closures and Callbacks</a></li>
<li><a href="#suspend">Suspending functions and coroutines</a></li>
<li><a href="#dispatch">Dispatchers</a></li>
<li><a href="#concur">Concurrency</a></li>
<li><a href="#channels">Channels</a></li>
<li><a href="#actors">Actors</a></li>
<li> ... </li>

  
</ol>
</td>

<td style="width:45%">
<img src="./KotlinInAction.png" alt="KotlinInAction" width="70%" height="40%">
 
</td>

</tr> 
</tbody>	
</table>
 





<h2><a id="basics"/>OVERVIEW</h2>

<ol>
<li>Basic elements of any computation are data and <bc>functions</bc> (data can be also viewed as functions that return values). </li>
<li>Functions are <bc>first class objects</bc> that have a type, can be assigned to variables and used as function arguments or as
return values.</li>
<li>Computations almost always require the usage of <bc>threads</bc> and to face concurrency problems, even in <tt>multi-core</tt> environments.</li>
<li><bc>Lexical Closures</bc> are often used as callbacks in <bc>asynchronous</bc> (IO-bound) programming according to a Continuation Passing Style (<bc>CPS</bc>)</li>
<li>The single-threaded <tt>event-loop model</tt> of Node.js (JavaScript) leads to the idea of message/job queue.</li>
<li>The Kotlin concept of <bc>coroutine</bc> allows us to introduce thread in a very light way. The concept is based on the idea
of suspend a  computation without blocking a thread (<bc>suspend function</bc>) implemented using (under the hoods) a state machine 
and <tt>CPS</tt>. </li>
<li>Kotlin <bc>channels</bc> promote interaction among coroutines in term of <tt>stream of values</tt>.</li>
<li>Kotlin <bc>actors</bc> promote a <tt>message-based programming style</tt> that overcomes traditional procedure-call interaction without
loosing in performance.</li>
</ol>

<h3><a id="data"/>Data, Types and Variables</h3>

<center><table style="width:95%">

<tbody>	
<tr>
<td style="width:45%"><pre> val counter : Int = 0</pre> </td>
<td><m><em>Immutable reference</em>. </m> </td>
</tr>

<tr>
<td><pre>var counter = 0</pre> </td>
<td><m><em>Mutable reference</em>. The Type <bc>Int</bc> is inferred</m> </td>
</tr>

<tr>
<td><pre>val name = "Bob"
val str = "Hello $name"
println( str )	//Hello Bob
</pre> </td>
<td><m><em>String template</em></m> </td>
</tr>


<tr>
<td><pre>val name : String? = null
val v = name?.length ?: 0
println("v=$v")	//0
</pre> </td>
<td><m><em>Nullable type</em> with safe null access</m> </td>
</tr>
<tr>
<td><pre>
val v : Any = 23
println( "v is String=${v is String}") //false
println( "v is Int=${v is Int}")	//true
</pre> </td>
<td><m><em>Type hierarchy</em>. <bc>Any</bc> is is a non-nullable type that denotes the root of the Kotlin class hierarchy. 
<bc>Unit</bc> is used as a return type of a function that has nothing to return
</m> </td>
</tr>


<tr>
<td><pre>var v : Any = "Bob"
println( "v is String=${v is String}") //true
println( "v is Int=${v is Int}")	//false
</pre> </td>
<td><m><em>Smart cast</em>. <bc>is</bc> is a predefined check operator (like Java <bc>instanceOf</bc>)</m> 
</td>
</tr>

<tr>
<td><pre>val v : Any = "Bob"
//val n = v.length //ERROR
val n = (v as String).length
println( "$n") //3
//println( "${v as Int}") //java.lang.ClassCastException
println( "${v as? Int}")  //null

val t : Int = v as? Int ?: 100
println( "$t") //100  //100
</pre> </td>
<td><m><em>Explicit casting</em>. The <bc>as</bc> operator performs type casting. 
The <bc>as?</bc> operator performs safe type casting
The <bc>?:</bc> is the <em>Elvis operator</em> that provides default values instead of null
</m> </td>
</tr>

<tr>
<td ><pre>
val s1 = "a"
var s2 = "a"
println( "s1 === s2 : ${s1 === s2} ") //true
println( "s1 == s2  : ${s1 == s2} ") //true

s2 = "b"
println( "s1 === s2 : ${s1 === s2} ") //false
s2 = "a"
println( "s1 === s2 : ${s1 === s2} ") //true

val a = java.io.File("a")
val b = java.io.File("a")
println( "a === b : ${a === b}") //false
println( "a == b  : ${a == b}") //true

</pre> </td>
<td><m><em>Referential equality</em> <bc>===</bc> and </m> <em>structural equality</em> <bc>==</bc> 
(that is translated into a call of the <bc>equals</bc> function of the class) </td>
</tr>

<tr>
<td><pre> 
val aToz = "a".."z"
val q = "q"
println( "q in aToz=${q in aToz}") //true
println( "1 in aToz=${"""1""" in aToz}") //false
</pre> </td>
<td><m><em>Range</em> created by the <bc>..</bc> operator.
The <bc>in</bc> infix operator performs a belong test. Triple quotes <bc>"""</bc> do not require escaping chars</m></td>
</tr>

<tr>
<td><pre>var a = arrayOf(1,2,3)
println( "array of size=${a.size}")
println( "firstEl=${a[0]}  lastEl=${a[a.size-1]}")
</pre> </td>
<td><m><em>Array</em>. They are a regular collection class. <bc>size</bc> is a <em>Property</em></m> </td>
</tr>


</tbody>	
</table></center>
 	

<h3><a id="funs"/>Functions</h3>

<center><table style="width:95%">
<tbody>	
<tr>
<td style="width:45%"><pre>fun sum(a:Int, b:Int) : Int {
  return a+b
}
println( " ${sum(3,6)} " ) //9
</pre> </td>
<td><m>A <em>Top-level function</em> that returns a value</m>
 </td>
</tr>

<tr>
<td><pre>var counter = 0
fun incCounter() : Unit{ counter++ }
fun decCounter() { counter-- }

println( "pre=$counter  " ) //pre=0
incCounter()
println( "post=$counter " ) //post=1
decCounter()
</pre> </td>
<td><m>Top-level functions that <em>do not </em> return a value. The return type <bc>Unit</bc> can be omitted</m></td>
</tr>

<tr>

<tr>
<td><pre>fun square(v: Int) = v * v
println( " ${square(3)} " ) //9
</pre> </td>
<td><m><em>One line function</em>. Braces can be omitted. Return type can be omitted (it is inferred)</m> </td>
</tr>






<td><pre>
val action : () -> Unit 	   
	//function type (no args, returns nothing useful (Unit)

val sum : ( Int,  Int) -> Int  
	//function type (two args, returns an Int)

val greet: ( String )-> ()->Unit
	//returns another function  
</td>
<td><m><em>Function type</em> is just a syntactic sugar for an interface, but the interface cannot be used explicitly.
We can  use it to type local variables, properties or arguments.
It is implemented in Java as a <bc>FunctionN</bc> interface.
<br/>
A  way to provide a value function is to use a <em>function literal</em>:

<ul>
<li><bc>Lambda expression</bc></li>
<li><bc>Anonymous function</bc></li>

</ul>
</m> </td>
</tr>

<tr>
<td><pre>
action	= { println("hello") }  //lambda expression
action() //hello

sum = { x:Int, y:Int -> x+y }  //lambda expression
val a = sum(1,2)
println("a=$a")	      //a=3

greet = { m: String -> { println(m)}  }
greet( "Hello World" )() //Hello World

---------------------------------------------------
{ println( "Welcome" ) }()  //Welcome

val fl = { print( "Last exp val=" ); 100 }
println( "${fl()}" )  //Last exp val=100
</td>
<td><m><em>Lambda Expression literal</em>: it can be assigned to a variable, just like any other literal. 
Returns (the value of the) <bc>last</bc> expression </m> </td>
</tr>

<tr>
<td><pre>
val action: ()->Unit = fun() { println("Hello") }
action() //hello

val sum: (Int)->Int  = fun(x) = x * x
println("sum=${sum(1,2)}")	      //sum=3

val greet: (String)->()->Unit = 
		fun(m:String) = fun() { println("Printing $m") }
greet( "Hello World" )() //Printing Hello World

------------------------------------------
fun exec23( op: ( Int, Int) -> Int ) {  op(2,3)  }

val v4 =  exec23( fun(x:Int,y:Int):Int{return x+y} )
println("$v4")          //5
</pre> </td>
<td><m><em>Anonymous function</em>; another way to write a block of code instead of a Lambda expression. Needs <bc>return</bc>
like any function </m> </td>
</tr>

<tr>
<td><pre>
fun exec23( op:(Int,Int) -> Int ) : Int { return op(2,3) }

val sum = { x:Int, y:Int -> x+y }
val mul = { x:Int, y:Int -> x*y }

println("${ exec23(sum) }")	      //5 
println("${ exec23(mul) }")	      //6

</td>
<td><m><em>Higher order functions</em>. </m> </td>
</tr>



<tr>
<td><pre>
fun exec23( op:(Int,Int) -> Int ) : Int { return op(2,3) }

val v1 = exec23( { x:Int, y:Int -> x-y } ) //no shortcut
println("v1=$v1")	      //v1=-1

val v2 = exec23() { x:Int, y:Int -> x-y } //lamda is last arg
println("v2=$v2")	      //v2=-1

val v3 = exec23{ x:Int, y:Int -> x-y } //() can be removed
println("v3=$v3")	      //v3=-1

val v4 = exec23{ x,y -> x-y } //arg types inferred
println("v4=$v4")	      //v4=-1

	
</td>
<td><m><em>Lambda syntax shortcut</em>. </m> </td>
</tr>

<tr>
<td><pre>
fun p2( op: ( Int ) -> Int ) : Int { return op(2) }

    val v1 = p2( { x:Int-> x*x } )
    val v2 = p2( )  { x:Int-> x*x }
    val v3 =  p2 { x:Int-> x*x }
    val v4 =  p2 { x -> x*x }
    val v5 =  p2 { it -> it*it }
    println("v5=$v5")	      //v45=4
</pre> </td>
<td><m><em>Simplification</em> in lambda call: </m>

<pre>
p2 { it*it }
</pre>

<m> The keyword <bc>it</bc> is an auto-generated parameter name </m></td>
</tr>



<td><pre>
fun modulo(k:Int): (Int) -> Int    //SIGNATURE
            = { it % k  }               //BODY
var v = modulo(3)(5)	
println("$v") //2
</pre> </td>
<td><m><em>Function as return value</em>.  </m> </td>
</tr>




<tr>
<td><pre>
</pre> </td>
<td><m><em></em></m> </td>
</tr>

<tr>
<td><pre>
fun sToN( s: String, base: Int=10 ) : Int{
    var v = 0
    for( i in 0..s.length-1 ) {
        v = ( s[i].toInt()-48 ) + v*base
    }
    return v
}

println( " ${ sToN( s: "123") } " ) //123
</pre> </td>
<td><m><em>Default parameters</em> and <em>Named parameters</em> at call </m> </td>
</tr>




<tr>
<td><pre>fun mirror(v: Int) : Pair&ltInt,Int> {
	return Pair(v, -v)
}
val v = mirror(2)
println("${v.first}, ${v.second} ")  //2,-2

val(pos,neg) = mirror(3)
println( " pos=$pos neg=$neg " ) //pos=3 neg=-3  
</pre> </td>
<td><m><em>Multiple return values</em>. To extract the values into separate values, we can exploit
<bc>destructuring declarations</bc> (syntactic sugar)</m> 
<pre>
val(pos,neg) = mirror(3)
</pre>
</td>
</tr>



<td><pre>fun sum(a:Int, b:Int) : Int {
  return a+b
}
println("${::sum}") //fun sum(kotlin.Int,kotlin.Int):kotlin.Int 
</pre> 
<m>To obtain the output, include the dependency on:</m>
<pre>
implementation "org.jetbrains.kotlin:kotlin-reflect"
</pre>
</td>
<td><m><em>Function reference</em>. The <bc>::</bc> operator creates a member reference or a (statically known) class reference.
The <em>reference</em> is a value of type <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html" target="web">KClass</a>.
A Kotlin class reference is not the same as a Java class reference. To obtain a Java class reference, 
use the <bc>.java</bc> property on a <tt>KClass</tt> instance.</m>
 </td>
 
 


<tr>
<td><pre>
fun curThread() : String { 
	return "thread=${Thread.currentThread().name}" 
}
</pre> </td>
<td><m><em>An utility function</em>: we will use it in the following</m> </td>
</tr>	
 
 
 <tr>
<td><pre>
fun main(args: Array<String>) {
    println("BEGINS")
    var str = "Hello World"
    str.let { println("$it!!") }
    println(str)
    println("ENDS")
}

//OUTPUT
BEGINS
Hello World!!
Hello World 
ENDS
</pre> </td>
<td><m>
<h5>Standard library function</h5> 

<em>let</em>  takes the object it is invoked upon as the parameter and returns the result of the lambda expression.
It is a <bc>scoping function</bc>, wherein the variables declared inside the expression cannot be used outside.
<!-- https://www.journaldev.com/19467/kotlin-let-run-also-apply-with 
useful higher order functions implementing idiomatic patterns.
-->
</m>
</td>
</tr>


<tr>
<td><pre>
fun testRunFunction() {
    val logo = "Global-logo"
    val v1 = run{ 
        println("First start:$logo  ${curThread()}")
        Thread.sleep(200)
        val logo = "First-run"
        println("First ended : $logo")
        logo
    }
    val v2 = run {
        println("Second start:$logo ${curThread()}")
        Thread.sleep(300)
        val logo = "Second-run"
        println("Second ended: $logo ")
        logo
    }
    println("logo=$logo v1=$v1 v2=$v2" )
}

fun main(args: Array<String>) {
    println("BEGINS")
    testRunFunction()
    println("ENDS")
}

//OUTPUT
BEGINS thread=main
Second start: Global-logo thread=main
First start : Global-logo thread=main
First ended : First-run
Second ended: Second-run 
logo=Global-logo v1=StandaloneCoroutine{.. v2=Second-run
ENDS thread=main
</pre> </td>
<td><m>
<h5>Standard library function</h5> 

<em>run </em> calls the specified function block and returns its result.
    It is a combination of <bc>with()</bc> and <bc>let()</bc> library functions.
	Similar to the <tt>let</tt> function, the run function returns the last statement.
	Unlike <tt>let</tt>, the <tt>run</tt> function doesn’t support the <bc>it</bc> keyword.
<!-- https://www.journaldev.com/19467/kotlin-let-run-also-apply-with 
useful higher order functions implementing idiomatic patterns.
-->
</m>
</td>
</tr>

</tbody>	
</table></center>
 

<h3><a id="clos"/>Closures and Callbacks</h3>

<center><table style="width:95%">
<tbody>	
<tr>
<td style="width:45%"><pre>
fun counterCreate()  : ( cmd : String ) -> Int {
    var localCounter = 0
    return {
        when (it) {
            "inc" -> ++localCounter
            "dec" -> --localCounter
            "val" -> localCounter
             else -> throw Exception( "unknown" )
        }
    }
}

val c1 = counterCreate()
for( i in 1..3 ) c1("inc")
println("c1=${c1("val")}")	      //c1=3

val c2 = counterCreate()	//another instance
for( i in 1..3 ) c2("dec")
println("c2=${c2("val")}")	     //c2=-3
</pre> </td>
<td><m>The <em>closure</em> returned by <bc>counterCreate</bc> is "closed over" the variable <bc>localCounter</bc>.
We are reproducing oo programming style (<i>instance</i> and <i>state encapsulation</i>)</m> </td>
</tr>

<tr>
<td><pre>
fun getInput() : String{
    println("Input  ...")
    return "myinput"
}
fun submit( v: Int, msg: String ) : String{
    println("Submit ...")
    return "$msg-$v"
}
fun handle( msg: String ){
    println("Handle $msg ${curThread()}")
}
fun doJob(n:Int){
    val s = getInput()
    val v = submit( n, s )
    handle( v )
}

fun main() = runBlocking{
    println("BEGINS")
    doJob(10)
    println("ENDS")
}

</pre> </td>
<td>
<m>
<h5>EXPERIMENT ON CPS</h5>
With reference to the set of functions on the left, let us execute a <em>Normal call sequence</em>:
The output is:</m>
<pre>
//OUPUT
BEGINS
Input  ...
Submit ...
Handle myinput-10
ENDS
</pre>
<m>Now, let us suppose that the operation <bc>getInput</bc> takes a long time and that we do not want to block
the computation. As a solution we could introduce:

<ol>
<li>Threading</li>
<li>Callbacks</li>
<li>Futures, Promises et al.</li>
<li>Reactive Extensions</li>
<li>Coroutines</li>
</ol>

</m>
</td>
</tr>

<tr>
<td><pre>
fun doJobCps( n: Int  ){
    getInputCps(
        { input -> submitCps( n, input, {
              msg ->  handle( msg )
            }//handle
        )}//submitCps
     )//getInputCps	
}
fun getInputCps( callback:( String )-> Unit):Unit{
    println("Input  ...${curThread()}")
    callback( "myinputcps" )
}
fun submitCps(v:Int,msg:String,callback:(String)->Unit){
    println("Submit ... ${curThread()}")
    callback( "$msg-$v" )
}
fun main() = runBlocking{
    println("BEGINS ${curThread()}")
    doJobCps( 10  )
    println("ENDS ${curThread()}")
}

//OUPUT
BEGINS thread=main
Input  ... thread=main 
Submit ... thread=main
Handle myinputcps-10  thread=main 
ENDS thread=main
</pre> </td>
<td><m><em>Callbacks</em> are quite common in <bc>event-loop</bc> architectures such as <b>JavaScript</b>.
The idea is to pass one function as a parameter to another function, and have this one invoked once the process has completed.
<br/>
In order to avoid the <bc>anti-pattern</bc> known as
 <a href="http://callbackhell.com/">callback hell</a>, people use other approaches such as <em>promises</em> or 
<em>Reactive Extensions</em> (<bc>Rx</bc>) (<tt>C#</tt>, <tt>.NET</tt>) .

 <br/><br/>
 The usage of callbacks leads to the
 <em>Continuation-passing style</em>  (see <a href="https://en.wikipedia.org/wiki/Continuation-passing_style" target="web">CPS</a>),
 quite diffused to handle 
 <a href="https://en.wikipedia.org/wiki/Asynchronous_I/O" target="web">Asynchronous I/O</a>
</m> 

 
</td>
</tr>

<tr>
<td><pre>
fun getInputAsynchCps(  callback : ( String ) -> Unit ) : Unit{
  kotlin.concurrent.thread(start = true) {
    println("Input  ...")
    Thread.sleep(1000)
	println("Input received ")
    callback( "myinputasynchcps" )
  }
}
fun doJobCps( n: Int  ){
  getInputAsynchCps(
   { input -> submitCps( n, input, {
                 msg ->  handle( msg )
             }//handle
     )}//submitCps
  )//getInputAsynchCps	
}

//OUPUT
BEGINS thread=main
ENDS thread=main
Input  ... thread=Thread-0 
Input received thread=Thread-0 
Submit ... thread=Thread-0
Handle myinputasynchcps-10  thread=Thread-0 
		
</pre> </td>
<td><m>
<h5>ASYNCHRONOUS PROGRAMMING WITH CPS</h5>
As an example of <a href="https://en.wikipedia.org/wiki/Continuation-passing_style" target="web">CPS</a> in <em>Asynchronous programming</em>
(see <a href="https://en.wikipedia.org/wiki/Asynchrony_(computer_programming)" target="web">asynchronous</a> ),
let us simulate here the <tt>getInput</tt> operation as an activity that runs in its own <bc>thread</bc>  and ends after <tt>1 sec</tt>.
<br/> 
Now, the <tt>main</tt> program ends immediately; the computation is executed in the thread activated for the input.
<br/><br/>
Note the <a href="https://kotlinlang.org/docs/reference/java-interop.html#sam-conversions">Single Abstract Method conversion</a> 
(<bc>SAM</bc>) in <tt>kotlin.concurrent.thread</tt>: when an object implements a <tt>SAM</tt> interface, we can pass a lambda instead.
</m> </td>
</tr>

</tbody>	
</table></center>

<h3><a id="suspend"/>Suspending functions and coroutines</h3>

<center><table style="width:95%">
<tbody>	

 <tr>
<td><pre>
suspend fun delayedFun(){
	println("delayedFun STARTS ${curThread()}")
	kotlinx.coroutines.delay(500)
	println("delayedFun ENDS ")
}
fun main() = runBlocking{
    println("BEGINS ${curThread()}")
    delayedFun()
    println("ENDS")
}

//OUTPUT
BEGINS thread=main
delayedFun STARTS thread=main
delayedFun ENDS 
ENDS thread=main
</pre> </td>
<td><m><em> </em>
<bc>delay</bc> is a special <i>suspending function</i> that does not block a thread, but suspends the work.
<br/><br/>
<bc>runBlocking</bc> is a  <tt>Coroutine Builder</tt> wrapper that runs new coroutine and blocks current thread interruptibly until its completion. 
It is designed to bridge regular blocking code to libraries that are written in suspending style, 
to be used in main functions and in tests.
<br/><br/>
A function that can <bc>suspend</bc> its work cannot be called from a normal function,
but only from another suspend function or from a <em>Coroutine</em>.

</m> </td>
</tr>



<tr>
<td style="width:45%"><pre>
suspend fun ioBoundFun(){
	val timeElapsed = measureTimeMillis {
		println("IO operation ${curThread()}")
		kotlinx.coroutines.delay(500)
	}
	println("Done, time=$timeElapsed")
}

fun main() = runBlocking{
    println("BEGINS ${curThread()}")
    ioBoundFun()
    println("ENDS")
}

//OUTPUT:
BEGINS thread=main
IO operation thread=main
Done, time=509
ENDS
</pre> </td>
<td><m>
Essentially a <em>Coroutine</em> is a light-weight thread that can be activated with a 
<em>Coroutine builder</em> into a <em>CoroutineScope</em>. 
<br/>
Among the <em>Coroutine Builder</em> there are:
<ul>
<li><bc>GlobalScope.launch</bc> | <bc>launch</bc> | <bc>async</bc></li>
<li><bc>GlobalScope.actor</bc></li>
</ul>


<bc>GlobalScope.launch</bc> is used to launch <tt>top-level coroutines</tt>, which operate on the whole application lifetime. 
However, we could launch coroutines in the specific scope of the operation we are performing.


</m> </td>
</tr>
  
 <tr>
<td><pre>
fun main() = runBlocking{
    println("BEGINS")
    val job = GlobalScope.launch {
        ioBoundFun()
    }
    println("ENDS")
}

//OUTPUT:
BEGINS thread=main
ENDS thread=main
IO operation thread=DefaultDispatcher-worker-1
</pre> </td>
<td><m>
A <em>Dispatcher</em> determines the thread in which a coroutine will be executed. It can be provided by the<tt> Coroutine Scope</tt>
or specified using a builder.
 
<br/>
The example shows that the coroutine works with reference to the <bc>Dispather.Deafault</bc>. Since
we do not await for coroutine completion, the programs ends before that the coroutine is done.
<br/><br/> 
 This dispatcher can be provided in two ways:

<ul>
<li><bc>Explicitly</bc>: the coroutine builder receives a coroutine context as a first parameter</li>
<li><bc>By the coroutine scope</bc></li>
</ul>



</m> </td>
</tr>
 
<tr>
<td><pre>
fun main() = runBlocking{
    println("BEGINS ${curThread()}")
    val job = GlobalScope.launch {
        ioBoundFun()
    }
    job.join()
    println("ENDS ${curThread()}")
}

//OUTPUT:
BEGINS thread=main
IO operation thread=DefaultDispatcher-worker-2
Done, time=514
ENDS thread=main
</pre> </td>
<td><m>Coroutines started by <bc>launch</bc> return a  <em>Job</em> immediately, which we can use to <tt>cancel</tt> 
the computation or <em>await</em> its completion with <bc>join</bc></m> </td>
</tr>

<tr>
<td><pre>
fun main() = runBlocking{
    println("BEGINS ${curThread()}")
    val job = launch {
        ioBoundFun()
    }
    //job.join()
    println("ENDS ${curThread()}")
}

//OUTPUT
BEGINS thread=main
ENDS thread=main
IO operation thread=main
Done, time=511
</pre> </td>
<td><m>
<h5>Structured concurrency</h5>

If we change <bc>GlobalScope.launch</bc> to just <bc>launch</bc>, then the coroutine is launched in the
scope of the outer <bc>runBlocking</bc> coroutine.
<br/><br/>
This is an example of  <em>structured concurrency</em>: coroutines confined to different scopes 
are more maintainable and manageable.
<br/><br/>
We can remove the explicit <bc>join</bc>, since <tt>runBlocking</tt> won't complete before all of its 
child coroutines finish.
</m>
 </td>
</tr>

<tr>
<td><pre>
suspend fun activate(){
    val job1 = GlobalScope.async{
        ioBoundFun()
    }
    val job2 = GlobalScope.async{
        ioBoundFun()
    }
    if(! job1.isCompleted || ! job2.isCompleted)
    println("Waiting for completion")
    val end1 = job1.await()
    val end2 = job2.await()
    println("All jobs done")
}

fun main() = runBlocking{
    println("BEGINS")
    activate()
    println("ENDS")
}

//OUTPUT
BEGINS thread=main
ENDS thread=main
Waiting for completion
IO operation thread=DefaultDispatcher-worker-1
IO operation thread=DefaultDispatcher-worker-2
Done, time=525
Done, time=525
All jobs done
ENDS
</pre> </td>
<td><m>The <bc>async</bc> builder returns a <em>promise</em> (also known as <tt>future</tt>), 
(which is of type <bc>Deferred</bc> in Kotlin): it promises to compute a value which we can wait for or 
request at any time.
<br/><br/>
 The method <bc>await</bc> on the promise allows us to get the value.


</m> </td>
</tr>

<tr>
<td><pre>
fun main() = runBlocking<Unit> {
 println("BEGINS ${curThread()}")
 launch { //context of the parent runBlocking  
  println("1) thread=${Thread.currentThread().name}")
 }
 launch(Dispatchers.Unconfined) { // in main thread
  println("2) thread=${Thread.currentThread().name}")
 }
 launch(Dispatchers.Default) { // DefaultDispatcher
  println("3) thread=${Thread.currentThread().name}")
 }
 launch(
  newSingleThreadContext("MyThr")) { //new thread
  println("4) thread=${Thread.currentThread().name}")
 }
 println("ENDS ${curThread()}")
}

//OUTPUT
BEGINS thread=main
2) thread=main
3) thread=DefaultDispatcher-worker-1
ENDS thread=main
4) thread=MyThr
1) thread=main
</pre> </td>
<td><m>
All the <tt>coroutine builder</tt> functions like <bc>launch</bc> and <bc>async</bc> accept as parameter one of the
following main Dispatchers:

<ol>
<li><bc>Default</bc>: for CPU-intensive tasks. It can use as many threads as CPU cores</li>
<li><bc>IO</bc>: IO-intensive tasks  waiting for an answer from another system. 
The size of this thread pool is 64</li>
<li><bc>newSingleThreadContext</bc> creates a new thread for the coroutine to run</li>
<li><bc>Unconfined</bc>: not confined -- will work with main thread (don’t use it unless you’re very sure of what you’re doing)</li>
<li><bc>Main</bc>: a special dispatcher that is included in <tt>UI</tt> related coroutine libraries
(see <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html" target="web">kotlinx.coroutines.Main</a>)</li>

</ol>


<!--
-Dkotlinx.coroutines.debug JVM option
https://play.kotlinlang.org
/koans/overview
-->
</m> </td>
</tr>


</tbody>	
</table></center>


 
<h3><a id="dispatch"/>Dispatchers</h3>
<center><table style="width:95%">
<tr>
<td style="width:45%"> <pre></pre> </td>
<td><m><em> </em></m> </td>
</tr>

<tr>
<td><pre>
suspend fun launchAction(i:Int,scope:CoroutineScope){
	...
}
fun main() = runBlocking {
 val cpus = Runtime.getRuntime().availableProcessors();
 println("AT START | 
    CPU=$cpus threads=${Thread.activeCount()} 
    curThread=${Thread.currentThread().name}")
 println("BEGINS")
 for (i in 1..6) launchAction(i,this) 
 println("ENDS")
}</pre> </td>
<td><m><em>Code pattern</em> for experiments on Dispatchers:
<ul>
<li>Coroutine dispatcher can confine coroutine execution to a specific thread, dispatch it to a thread pool, 
or let it run unconfined.</li>
<li>Coroutines can be executed concurrently using a multi-threaded dispatcher.</li>
<li>Coroutines can suspend on one thread and resume on another thread.</li>
</ul>

</m> </td>
</tr>


<tr>
<td><pre>
suspend fun launchAction(i:Int,scope:CoroutineScope){
	launchDefault(i,scope)
}
suspend fun launchDefault(i:Int,scope:CoroutineScope){
    scope.launch( Dispatchers.Default ){ action(i) }
}

//OUTPUT
AT START | CPU=4 threads=2 curThread=main
BEGINS
1) thread=DefaultDispatcher-worker-1
2) thread=DefaultDispatcher-worker-2
ENDS
3) thread=DefaultDispatcher-worker-4
4) thread=DefaultDispatcher-worker-3
6) thread=DefaultDispatcher-worker-1
5) thread=DefaultDispatcher-worker-4
Action 3 done
Action 1 done
Action 6 done
Action 5 done
Action 4 done
Action 2 done
</pre> </td>
<td><m><em>Dispatch.Default</em>: the actions are executed by as many Threads as the CPU cores
 
</m> </td>
</tr>

<tr>
<td><pre>
suspend fun launchAction(i:Int,scope:CoroutineScope){
	launchIO(i,scope)
}
suspend fun launchIO(i:Int,scope:CoroutineScope){
    scope.launch( Dispatchers.IO ){ action(i) }
}

//OUTPUT
AT START | CPU=4 threads=2 curThread=main
BEGINS
1) thread=DefaultDispatcher-worker-1
ENDS
2) thread=DefaultDispatcher-worker-2
3) thread=DefaultDispatcher-worker-3
4) thread=DefaultDispatcher-worker-4
5) thread=DefaultDispatcher-worker-5
6) thread=DefaultDispatcher-worker-6
Action 6 done
Action 2 done
Action 5 done
Action 3 done
Action 4 done
Action 1 done
</pre> </td>
<td><m><em>Dispatch.IO</em>: the actions are executed by a pool of (<tt>64??</tt>) Threads 
 
</m> </td>
</tr>

<tr>
<td><pre>
val th = newSingleThreadContext("My Thread")

suspend fun launchAction(i:Int,scope:CoroutineScope){
	launchSingle(i,scope)
}
suspend fun launchSingle(i:Int,scope:CoroutineScope){
    scope.launch( th ){ action(i) }
}

//OUTPUT
AT START | CPU=4 threads=2 curThread=main
BEGINS
1) thread=My Thread
ENDS
2) thread=My Thread
3) thread=My Thread
4) thread=My Thread
5) thread=My Thread
6) thread=My Thread
Action 1 done
Action 2 done
Action 3 done
Action 4 done
Action 5 done
Action 6 done
</pre> </td>
<td><m><em>Thread confinement </em>: : the actions are executed one a e time (in <tt>mutual exclusion</tt>)
by a <bc>single thread</bc>
 
</m> </td>
</tr>



</tbody>	
</table></center>

<h3><a id="concur"/>Concurrency</h3>

<center><table style="width:95%">
<tr>
<td style="width:45%"> <pre></pre> </td>
<td><m><em> </em></m> </td>
</tr>

<tr>
<td><pre>
var counter = 0

suspend fun CoroutineScope.massiveRun(
				action: suspend () -> Unit) {
    val n=100  //number of coroutines to launch
    val k=1000 //times an action is repeated by each coroutine
    val time = measureTimeMillis {
        val jobs = List(n) {
            launch {
                repeat(k) { action() }
            }
        }
        jobs.forEach { it.join() }
    }
    println("Completed ${n * k} actions in $time ms")    
}
</pre> </td>
<td><m>
<h5>Case study: CounterIncCoroutines</h5>

<em>Concurrency</em>. Let us introduce an example taken from<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/shared-mutable-state-and-concurrency.md#actors" target="web">
Kotlin coroutines: Shared mutable state and concurrency</a>:<br/>
<li><tt>n=100</tt> coroutines are launched to execute <tt>k=1000</tt> times a given <b>action</b> of signature <tt>suspend () -> Unit</tt></li>
<li>the  action  will be the increment of the shared variable <bc>counter</bc> </li>
<br/><br/>
We will make reference to the example with the name  "<bc>CounterIncCoroutines</bc>".
</m>
</td>
</tr>

<tr>
<td><pre>
fun main() = runBlocking<Unit>{
    val cpus = Runtime.getRuntime().availableProcessors();
    println("BEGINS with $cpus  cores")
    GlobalScope.massiveRun {
         counter++
    }
    println("ENDS with Counter = $counter")
}

//OTPUT
BEGINS with 4  cores
Completed 100000 actions in 55 ms
ENDS with Counter = 83987
</pre> </td>
<td><m><em>No synchronization</em>. We use the multi-threaded <bc>Dispatcher.Defaults</bc> within a computer with <tt>4</tt> cores.
Since the increment operation <tt>counter++</tt> is <bc>not atomic</bc> some increment is lost
and the final value is less then <tt>10000</tt> .
</m></td>
</tr>

<tr>
<td><pre>
var counter = java.util.concurrent.atomic.AtomicInteger()

fun main() = runBlocking<Unit>{
    val cpus = Runtime.getRuntime().availableProcessors();
    println("BEGINS with $cpus  cores")
    GlobalScope.massiveRun {
            counter.incrementAndGet()
    }
    println("ENDS with Counter = ${counter.get()}")
}

//OUTPUT
BEGINS with 4  cores
Completed 100000 actions in 55 ms
ENDS with Counter = 100000

</pre> </td>
<td><m><em>Thread-safe data</em>. Thread-safe (synchronized, linearizable, atomic) data structure  are a general solution 
that works both for threads and for coroutines. However, it does not easily scale to complex state or to complex operations.

</m> </td>
</tr>



<tr>
<td><pre>
val counter = 0
val counterContext = 
	newSingleThreadContext("CounterContext")

fun main() = runBlocking<Unit>{
 val cpus = Runtime.getRuntime().availableProcessors();
 println("BEGINS with $cpus  cores")
 GlobalScope.massiveRun {
   //run each coroutine with DefaultDispathcer 
   withContext(counterContext) {
    //confine each increment to the single-threaded context
    counter++
  }
 }
 println("ENDS with Counter = $counter")
}

//OUTPUT
BEGINS with 4  cores
Completed 100000 actions in 902 ms
ENDS with Counter = 100000

</pre> </td>
<td><m><em>Thread confinement fine-grained</em>. Each coroutine is launched with DefaultDispathcer, but each increment is confined
to a single-threaded context. 
<br/>
Each individual increment switches from multi-threaded <bc>Dispatchers.Default</bc> context to the 
<bc>newSingleThreadContext</bc> using <bc>withContext</bc> block. Thus, the code works more slowly.

</m> </td>
</tr>


<tr>
<td><pre>
val mutex = kotlinx.coroutines.sync.Mutex()

fun main() = runBlocking<Unit>{
    val cpus = Runtime.getRuntime().availableProcessors();
    println("BEGINS with $cpus  cores")
    GlobalScope.massiveRun {
        mutex.withLock { counter++ }
    }
    println("ENDS with Counter = $counter")
}

//OUTPUT
BEGINS with 4  cores
Completed 100000 actions in 480 ms
ENDS with Counter = 100000

</pre> </td>
<td><m>A <em>Critical section</em> protects all modifications of a shared state so that is never executed concurrently 
(but it is accessed in <bc>mutual exclusion</bc>). The Coroutine's alternative to  <tt>synchronized</tt> operations is <bc>Mutex</bc>.
<br/>
The locking here is fine-grained and the execution is quite slow. However, it can be  it is a good solution
 when there is no natural thread in which we can confine a shared state to be modified.


</m> </td>
</tr>

<tr>
<td><pre>
val simpleProducer = produce {
        send(1)
}
println(simpleProducer.receive()) //1

val context = newSingleThreadContext("myThread")
val typedProducer: ReceiveChannel<Any> = produce(context){
	send(5)
	send("a")
	send(100)
}
println(typedProducer.receive()) //1
typedProducer.consumeEach {
   println(it)
}


</pre> </td>
<td><m>A <em>Producer</em> works as follows:
<ul>
<li>suspends after a value s produced and  resumes when a new value is requested (similar to suspending sequences anmd iterators)</li>
<li>can be built with a specific <tt>CoroutineContext</tt> (as with <tt>launch</tt> or <tt>async</tt>) </li>
<li>the body of the suspending lambda that is passed can suspend at any point</li>
<li>a value from a producer can only be received in a suspending computation </li>
</ul>

A producer is associated with the channel that it sends elements to (a <bc>ReceiveChannel</bc>) .
</m> </td>
</tr>

</tbody>	
</table></center>

<h3><a id="channels"/>Channels</h3>

<center><table style="width:95%">
<tbody>	
<tr>
<td style="width:45%"><pre>
suspend fun channelTest(){
 val timeElapsed = measureTimeMillis {
     val n = 5
     val channel = Channel<Int>(2)

     val sender = GlobalScope.launch {
         repeat( n ) {
             channel.send(it)
             println("SENDER | sent $it")
         }
     }
     delay(500) //The receiver starts after a while ...
     val receiver = GlobalScope.launch {
         for( i in 1..n ) {
             val v = channel.receive()
             println("RECEIVER | receives $v")
         }
     }

     delay(3000)
 }
    println("Done. time=$timeElapsed")
}

//OUTPUT
BEGINS
SENDER | sent 0
SENDER | sent 1
RECEIVER | receives 0
SENDER | sent 2
SENDER | sent 3
RECEIVER | receives 1
RECEIVER | receives 2
RECEIVER | receives 3
RECEIVER | receives 4
SENDER | sent 4
Done. time=3556
ENDS
</pre> </td>
<td><m>Channels provide a way to transfer a <tt>stream of values</tt>. <bc>send</bc> and <bc> receive</bc>  are
<em>suspending functions</em> used for providing and consuming objects from the channel, implemented with a <tt>FIFO</tt>
strategy.

<br/><br/>
The example shows the usage of an <bc>ArrayChannel</bc> of capacity <tt>2</tt>. The sender is suspended when the channel is full
and resumes as soon as the receiver consumes the data. This concept i often referred to as <em>Backpressure</em> and helps to
prevent a channel from being flooded with more elements than the receivers can actually process.

<br/><br/>
Kotlin defines several types of channels:

<br/><br/>
<em>Unbuffered Channels</em>:
<ul>
 
<li><bc>RendezvousChannel</bc> (the buffer has capacity <tt>0</tt> and the sender suspends until the element is consumed)</li>
</ul>

<em>Buffered Channels</em>:
<ul>
<li><bc>LinkedListChannel</bc></li>
<li><bc>ArrayChannel</bc></li>
<li><bc>ConflatedChannel</bc> (the buffer has capacity <tt>1</tt> and the sender overrides an element not cosumed)</li>
</ul>

</m> </td>
</tr>

 

</tbody>	
</table></center>

 
<h3><a id="actors"/>Actors</h3>

<center><table style="width:95%">
<tbody>	

<tr>
<td><pre>
class CounterMsg(
  val cmd:String,val response:CompletableDeferred<Int>?=null){
}

fun CoroutineScope.counterActor() : SendChannel<CounterMsg> =
            actor<CounterMsg> {
    var localCounter = 0 // actor state
    for (msg in channel) { // iterate over incoming messages
        when ( msg.cmd ) {
            "INC" -> localCounter++
            "DEC" -> localCounter--
            "GET" -> msg.response?.complete(localCounter) 
            else -> throw Exception( "unknown" )
        }    }
}

fun main() = runBlocking<Unit>{
    val cpus = Runtime.getRuntime().availableProcessors();
    println("BEGINS with $cpus  cores")
    val counter = counterActor() // create the actor
    val initVal = CompletableDeferred<Int>()
    counter.send(CounterMsg("GET", initVal))
    println("Counter INITIAL VALUE=${initVal.await()}")
    GlobalScope.massiveRun {
        counter.send(CounterMsg("INC") )
    }
    val finalVal = CompletableDeferred<Int>()
    counter.send(CounterMsg("GET", finalVal))
    println("Counter FINAL VALUE= = ${finalVal.await()}")
    counter.close() // shutdown the actor
    println("ENDS ")
}

//OUTPUT
BEGINS with 4  cores
Counter INITIAL VALUE=0
Completed 100000 actions in 734 ms
Counter FINAL VALUE= = 100000
ENDS 
</pre> </td>
<td><m>
Our <bc>CounterIncCoroutines</bc> problem, can be solved by 'embedding' the counter-data into an <em>Actor</em> that:
<ul>
<li>confines the access of a state to a single Coroutine</li>
<li>is associated with the <bc>channel</bc> (<tt>unbuffered</tt> by default ) that it receives messages from</li>
<li>modifies the state by handling the messages received on its <bc>channel</bc> </li>
<li>has type <bc>SendChannel&ltT></bc> where <tt>T</tt> is the type of message it can handle</li>
</ul>

This combination of mechanisms opens the way to the concept of <em>state share by communication</em>.
<!-- A simple actor can be written as a function, but an actor with a complex state is better suited for a class.
An actor is associated with the <bc>channel</bc> ( <bc>unbuffered</bc> by default ) that it receives messages from (of type <bc>SendChannel<T></bc>)
-->
<br/>
In this version
The Actor has always work to do and does not have to switch to a different context at all.

<br/><br/>
The first step of using an actor is to define a class of messages that an actor is going to process.
Kotlin's <bc>sealed classes</bc> are well suited for that purpose. However, at the moment, we introduce a more conventional class
<bc>CounterMsg</bc>.

<br/>
The <b>action</b> consists now in sending a <tt>CounterMsg</tt> with <tt>cmd="INC"</tt> .

<br/>
The final value of the counter is obtaind by sending to the actor the <tt>CounterMsg</tt> with <tt>cmd="GET"</tt> 
and <tt>response</tt> bound to an object that will include the response, once available.
<br/>
The object of <bc>CompletableDeferred</bc> interface 
(see <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-completable-deferred/" target="web">CompletableDeferred</a>))
is a <tt>Deferred</tt> that can be completed via public functions <bc>complete</bc> or <bc>cancel</bc>.
All functions on this interface and on all interfaces derived from it, are <bc>thread-safe</bc> and can be safely invoked 
from concurrent coroutines without external synchronization.
<br/><br/> 
The <bc>actor</bc> coroutine builder is a dual of <bc>produce</bc> coroutine builder, 
since a producer is associated with the channel that it <i>sends</i> elements to.



</m> </td>
</tr>



 



</tbody>	
</table></center>

<h3>OTHER</h3>

<center><table style="width:95%">
<tbody>	
<tr>
<td style="width:45%"><pre></pre> </td>
<td><m> 
<h5>Rules overview</h5>
The execution of a coroutine always happens inside a <em>Coroutine Context</em> that defines <b>how</b> the coroutine will be executed
(see <a href="https://proandroiddev.com/demystifying-coroutinecontext-1ce5b68407ad" target="web">Demystifying CoroutineContext</a>).
It includes a coroutine <em>Dispatcher</em>.


<br/><br/>
Every coroutine builder, including <tt>runBlocking</tt> is an extension on <em>CoroutineScope</em> interface 
and inherits its abstract read-only property
<tt>coroutineContext: CoroutineContext</tt> to  automatically propagate both context elements and cancellation.
See <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html" target="web">
Coroutine Scope</a>
<ul>
<li><bc>Global scope</bc>: the coroutine affects the whole Application</li>
<li><bc>CoroutineScope</bc>: defines a scope for new coroutines</li>
</ul>
 

A Context can be composed  by several element types to create <em>composed behaviors</em>.
</m> </td>
</tr>

<tr>
<td><pre>
suspend fun actionWithContext( n: Int){
 withContext(Dispatchers.Default) {
   println("$n) thread=${Thread.currentThread().name}")  
   delay(1000)
   println("ActionWithContext $n done")
 }
}
fun main() = runBlocking{
	println("BEGINS")
    for(i in 1..3) launch{ actionWithContext(i) } 
    println("ENDS")
}

//OUPUT
BEGINS
ENDS
1) thread=DefaultDispatcher-worker-1
2) thread=DefaultDispatcher-worker-2
3) thread=DefaultDispatcher-worker-3
ActionWithContext 3 done
ActionWithContext 1 done
ActionWithContext 2 done
</pre> </td>
<td><m><em>withContext</em>: allows to 
change the context that will be used to run a part of the code inside a coroutine.

 
</m> </td>
</tr>

 <tr>
<td><pre></pre> </td>
<td><m></m> </td>
</tr>

 <tr>
<td><pre>
fun main(){
    val cpus = Runtime.getRuntime().availableProcessors();
    println("AT START | CPU=$cpus ")
    println("BEGINS ${curThread()}")
    println("MAIN | ${curThread()}")
    var continuation: Continuation<Unit>? = null
    GlobalScope.launch(Dispatchers.Unconfined) {
        println("COROUTINE |  started")
        suspendCoroutine<Unit> {
            println("COROUTINE | suspended ${curThread()}")
            continuation = it
        }
        println("COROUTINE|resumes&finish ${curThread()}")
    }
    println("MAIN | resumes continuation ${curThread()}")
    continuation?.resume(Unit) ?: println("MAIN | no contin")
    println("MAIN |  back after resume")
    println("ENDS ${curThread()}")
}

//OUTPUT
AT START |  CPU=4  
BEGINS thread=main
MAIN | thread=main
COROUTINE |  started
COROUTINE | suspended thread=main
MAIN | resumes continuation thread=main
COROUTINE|resumes&finish thread=main
MAIN |  back after resume
ENDS thread=main
</pre> </td>
<td><m>
Coroutines do not rely on features of the Operating System or the J<tt>VM</tt>. Instead, a <bc>Continuation</bc> is added to every suspending function as 
an additional parameter according to the <bc>CPS</bc> style. The compiler produces a <em>state machine</em> to handle suspension.
<br/><br/>

<ol>
<li><tt>main</tt> activates a coroutine with <bc>Unconfined dispatcher</bc> that doesn't do any dispatching: the coroutine
code works within <tt>main</tt> thread</li>
<li>The coroutine suspends its work by using  <bc>suspendCoroutine</bc>.</li>
<li>The control returns to the <tt>main</tt> that uses a <bc>Continuation<Unit></bc>  set by the coroutine
to resume it.</li>
<li>The coroutine ends and the control is given back to the <tt>main</tt> that ends</li>

</ol>

If we launch the coroutine with <bc>Dispatchers.Default</bc> (or some other confined form), the output will be:</m>
<pre>
//OUTPUT
BEGINS thread=main
MAIN | thread=main
MAIN | resumes continuation thread=main
MAIN | no contin
MAIN |  back after resume
ENDS thread=main

</pre>

</td>
</tr>


<tr>
<td><pre>
fun testRunFunction() {
    runBlocking {
    val logo = "Global-logo"
    val v1 = launch(Dispatchers.Default){ 
        println("First start : $logo 
			thread=${Thread.currentThread().name}")
        Thread.sleep(200)
        val logo = "First-run"
        println("First ended : $logo")
        logo
    }
    val v2 = run {
        println("Second start: $logo 
			thread=${Thread.currentThread().name}")
        Thread.sleep(300)
        val logo = "Second-run"
        println("Second ended: $logo ")
        logo
    }
    println("logo=$logo v1=$v1 v2=$v2" )
    }
}

fun main(args: Array<String>) {
    val cpus = Runtime.getRuntime().availableProcessors();
    println("AT START | 
		CPU=$cpus threads=${Thread.activeCount()}")
    println("BEGINS")
    testRunFunction()
    println("ENDS")
}

//OUTPUT
AT START | CPU=4 threads=2  
BEGINS
Second start: Global-logo  thread=main
First start : Global-logo thread=DefaultDispatcher-worker-2
First ended : First-run
Second ended: Second-run 
logo=Global-logo v1=StandaloneCoroutine{... v2=Second-run
ENDS 
</pre> </td>
<td><m><em>Experiments</em> Let us launch the coroutine with the <bc>coroutineContext</bc> </m>
<pre>val v1 = launch(kotlin.coroutines.coroutineContext)
</pre>
<m>Now, the <tt>OUTPUT</tt> is</m>
<pre>
BEGINS
Second start: Global-logo  thread=main
Second ended: Second-run 
logo=Global-logo v1=StandaloneCoroutine{... v2=Second-run
First start : Global-logo thread=main
First ended : First-run
ENDS
</pre>
<m>In fact, since all run are on the <tt>main</tt> thread, <tt>launch</tt> is suspended until <tt>run</tt> completes.
<br/>
If we replace <tt>Thread.sleep</tt> with <bc>kotlin.coroutines.delay</bc>, the <tt>OUTPUT</tt> is:</m>
<pre>
BEGINS
Second start: Global-logo  thread=main
First start : Global-logo thread=main
First ended : First-run
Second ended: Second-run 
logo=Global-logo v1=StandaloneCoroutine{... v2=Second-run
ENDS
</pre>
<m>In fact, <bc>delay</bc> does not block the thread, but releases it for the (other) coroutine and regains it back
when the thread is further released.
</m> </td>
</tr>


 
 
 
 
<tr>
<td><pre>


val fibonacciSeq = buildSequence {
    var a = 0
    var b = 1
 
    yield(1)
 
    while (true) {
        yield(a + b)
 
        val tmp = a + b
        a = b
        b = tmp
    }
}

 fun main() {
    println("BEGINS")
    printSequence()
    val v = sequence.elementAt(2)
    println("v=$v")
//Sequences are stateless and they reset after being used
    val firstTwo = sequence.take(2)   //calculated at later tine
    println("firstTwo=${firstTwo.joinToString()}")
    println("ENDS")
}

 

//OUPUT
BEGINS
 
ENDS
</pre> </td>
<td><m>A suspend function can suspend its execution while waiting for the execution of one or more computations to happen.
<br/><br/>
Instead, a 
<em> suspendable sequence </em> is a coroutine builder taht can suspend between invocation by using the <bc>yield()</bc> function.


</m> </td>
</tr> 

</tbody>	
</table></center>



<!--

<h3><a id=" "/>Next</h3>

<center><table style="width:95%">
<tbody>	
<tr>
<td style="width:45%"> <pre></pre> </td>
<td><m><em> </em></m> </td>
</tr>

<tr>
<td><pre></pre> </td>
<td><m><em> </em></m> </td>
</tr>

</tbody>	
</table></center>
-->
 
<br/><br/> 
</div>  

</body>
</html>

<!--
class CounterMsg( 
	val cmd:String, val replyChannel:SendChannel<Int>?=null){
}

fun counterActor() : SendChannel<CounterMsg> = GlobalScope.actor<CounterMsg> {
    var localCounter = 0 // actor state
    for (msg in channel) { // iterate over messages
        when ( msg.cmd ) {
            "INC" -> localCounter++
            "DEC" -> localCounter--
            "GET" -> msg.replyChannel?.send(localCounter)
            else -> throw Exception( "unknown" )
        }    }
}

suspend fun useTheCounter(){
    val counter = counterActor()
    println("INC")
    counter.send( CounterMsg("INC") )

    val answerChannel = Channel<Int>()
    counter.send( CounterMsg("GET", answerChannel) )

    val answer = answerChannel.receive()
    println("useTheCounter COUNTER = $answer")
}

fun main() = runBlocking{
    println("BEGINS")
    useTheCounter()
    println("ENDS")
}

//OUTPUT
BEGINS with 4  cores
INC
useTheCounter COUNTER = 1
ENDS 
-->