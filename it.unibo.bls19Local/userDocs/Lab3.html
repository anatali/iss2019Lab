<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
<!--

body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin: 10;
    margin-right: 15px;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
    border-bottom: 1px solid #242424;
}

h1 {
    font-size: 150%;
    background-color: #b2c0ff;
}

h2 {
    background-color: #d9fbff;
    font-size: 110%;
}

h3 {
	background-color: #e6ccff;
    font-size: 80%;
}
h4 {
    background-color: #99ffcc;
    font-size: 100%;
	width: 750px;
}
#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 80%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #ccffff;
    color: #0033cc;
}
bc{
	font-family: "Arial";
	font-size: 80%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
pre{
	font-family: "Helvetica";
	font-size: 80%;
	background-color: #fcf8c7;
	border: 1px solid blue;
	width: 700px;
}
div.body{
	width: 800px;
    font-size: 18px;
}    
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}    

table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}

  -->
</style>
    
<head>
   
<title>ISSLAB2019</title></head>
    
<body>

<div class="body"> 

<h1>72939 - LAB3 | A ButtonLedSystem framework</h1> 
<a href="http://infolab.ingce.unibo.it/iss2018/it.unibo.issMaterial/issdocs/Material/LectureBologna1819.html" target="isslm">LabSS-lectures site</a></font> 

<h2>REQUIREMENTS</h2>
<div class="req">
Refactoring the <tt>BLS</tt> system introduced in <a href="Lab1.html" target="info">Lab1.html</a> so to provide a reusable software 
<a href="https://en.wikipedia.org/wiki/Software_framework">framework</a> for <tt>BLS</tt> applications.
</div>	    
 	
	
<h2>TOWARD SYSTEM MODELLING</h2>
<p>
The architecture of the <tt>BLS</tt> system introduced in <a href="Lab1.html" target="info">Lab1.html</a>  and later extended in
<a href="Lab2.html" target="info">Lab2.html</a>, includes components
that represent, concrete devices, for example a
<a href="../src/main/java/it/unibo/bls/devices/mock/LedMock.java" target="code">LedMock</a> or a
 <a href="../src/main/java/it/unibo/bls/devices/gui/ButtonAsGui.java" target="code">ButtonAsGui</a>.
<br/>
 To enhance flexibility and reusability, a <a href="../src/main/java/it/unibo/bls/devices/DeviceFactory.java" target="code">DeviceFactory</a>
 is introduced, that works with reference to a set of <em>device types</em> (
 <a href="../src/main/java/it/unibo/bls/devices/LedType.java" target="code">LedType</a> and
	<a href="../src/main/java/it/unibo/bls/devices/ButtonType.java" target="code">ButtonType</a>).
</p><p>
Let us now replace any specific device with a <em>device model</em> (for a quick introduction on the role of models in software, you can see 
<a href="https://en.wikipedia.org/wiki/Conceptual_model_(computer_science)" target="web">Conceptual model</a> and
<a href="https://en.wikipedia.org/wiki/Systems_modeling" target="web">Systems modeling</a>) with the aim of captureing 
the relevant properties of the device (without any reference to its technological aspects).
</p><p>

<h3>Digital twins</h3>
In the context of the  <a href="https://en.wikipedia.org/wiki/Internet_of_things">Internet of things</a>, we can read  that a
<a href="https://en.wikipedia.org/wiki/Digital_twin">digital twin</a> is:

<ul>
<li>a dynamic virtual representation of a physical object or system across its lifecycle, 
using real-time data to enable understanding, learning and reasoning;</li>
<li>a real time digital replica of a physical device;</li>
<li>a digital replica of a living or non-living physical entity. By bridging the physical and the virtual world, 
data is transmitted seamlessly allowing the virtual entity to exist simultaneously with the physical entity</li>
<li>...</li>
</ul>

The introduction of the concept of <em>digital twin</em> is going to 'disruptt' the entire <em>Product Lifecycle Management</em> (<tt>PLM</tt>), 
from manufacturing to service and operations.
Digital twins offer a great amount of business potential by predicting the future instead of analyzing the past of the manufacturing process.

<h2>MODELLING THE DEVICES</h2>
Our definition of a model for the <tt>Led</tt> and for the <tt>Button</tt> is at the moment quite simple, since it is limited to capture
the idea of a components with a <bc>state</bc>, represented as a <tt>boolean</tt> variable.
</p><p>
<center><img src="./blsLogicModels.png" alt="blsLogicModels" width="70%" height="70%"></center>
</p><p>
Our models for the <tt>Led</tt> and for the <tt>Button</tt> are defined so to be <em>observable</em>; moreover, the model of the <tt>Button</tt>
is also defined as an <em>observer</em>.
</p><p>
<center><table style="width:90%">
  <tr>
    <th>Interfaces</th>
    <th>Models</th> 
	<th>Application logic</th>
    </tr>
<tr>
<td>
<ul>
<li><a href="../src/main/java/it/unibo/blsFramework/interfaces/IButtonModel.java" target="code">IButtonModel</a></li>
<li><a href="../src/main/java/it/unibo/blsFramework/interfaces/ILedModel.java" target="code">ILedModel</a></li>
<li><a href="../src/main/java/it/unibo/blsFramework/interfaces/IAppLogic.java" target="code">IAppLogic</a></li>
<li><a href="../src/main/java/it/unibo/blsFramework/interfaces/IApplListener.java" target="code">IApplListener</a></li>
<li><a href="../src/main/java/it/unibo/blsFramework/interfaces/IBlsFramework.java" target="code">IBlsFramework</a></li>
</ul>	
</td>
<td>
<ul>
<li><a href="../src/main/java/it/unibo/blsFramework/models/ButtonModel.java" target="code">ButtonModel</a> (<tt>boolean buttonState</tt>)</li>
<li><a href="../src/main/java/it/unibo/blsFramework/models/LedModel.java" target="code">LedModel</a> (<tt>boolean ledState</tt>)</li>
</ul>	
</td> 
<td><a href="../src/main/java/it/unibo/blsFramework/applLogic/BlsApplicationLogic.java" target="code">BlsApplicationLogic.java</a><br/>
<a href="../src/main/kotlin/it/unibo/blsFramework/kotlin/applLogic/BlsApplicationLogic.kt" target="code">BlsApplicationLogic.kt</a>
</td>
</tr>
 </table></center>
 </p><p>
 Our ideas can be summarized as follows:

<ul>
<li>The  model  of any <bc>input/sensor</bc> device (like a <tt>Button</tt>) should evolve according to information that arises from some
concrete device, i.e. it should be an <em>Observer</em>. Moreover, it should be also an <em>Observable</em> in order to propagate
information about changes, by avoiding the need of polling on it.</li>
<li>The model of any <bc>output/actuator</bc>  device (like a <tt>Led</tt>) should be an <em>Observable</em>,
since it should send information (when it changes)
 to some concrete device without being obliged to know such a device in static way.</li>
 <li>A <b>system</b> based on proper set of models can be designed, build and tested <em>once and for all</em>. Concrete devices can be
 added (also in a dynamic way) as <i>observers</i> (if output devices) or as <i>observable</i> (if input devices). In other
 words, we can design and build a reusable software <a href="https://en.wikipedia.org/wiki/Software_framework">framework</a>.</li>
 <li>An <b>application built upon the framework</b> can be logically conceived as a software system composed of two main parts: 
 a <em>logical, high-level</em> part (the framework) that does not change and a <em>technology-dependent, lower-level</em>  part 
 that provides concrete components  to be 'injected' into the logical part.</li>
</ul> 

<center><img src="./blsLogicModelsAndConcrete.png" alt="blsLogicModelsAndConcrete" width="80%" height="80%"></center> 

</p> 

 
 <h2>A BLS FRAMEWORK</h2>
 
Our  <tt>BLS</tt> framework is implemented by the class 
<a href="../src/main/java/it/unibo/blsFramework/appl/BlsFramework.java" target="code">BlsFramework</a> and is deployed with
the jar file named <a href="../build/libs/it.unibo.bls19Local-1.0.jar" target="code">it.unibo.bls19Local-1.0.jar</a>.

Its internal organization  is based on the 
<em>basic steps</em> required to set-up any software system:

<ul>
<li><bc>createLogicalComponents</bc> : creates the objects that represents the components of the framework.</li>
<li><bc>configureSystemArchitecture</bc> : 'injects' references to the components in order to create a local network
of interrelated objects.</li>
</li>
</ul>
<p>
There are also (as required by the <a href="../src/main/java/it/unibo/blsFramework/interfaces/IBlsFramework.java" target="code">IBlsFramework</a>
interface) methods (<bc>setConcreteLed</bc> and <bc>setConcreteButton</bc>, <bc>addConcreteLed</bc>) to set/add device-objects to the system and
selector methods (e.g. <bc>getLedModel</bc>, <bc>getButtonConcrete</bc>) to acquire a reference to the last specific component added to the system.
<br/>
The framework has no explicit <tt>startTheSystem</tt> method, since in this case the computation will start as consequance
of a state change in a  <tt>concrete Button</tt>.
</p><p>
 
 We can reuse several components already introduced in
 <a href="Lab1.html" target="info">Lab1.html</a> and <a href="Lab2.html" target="info">Lab2.html</a>, in particular: 
 <ul>
 <li>we can reuse the <a href="../src/main/java/it/unibo/bls/listener/ButtonObserver.java" target="code">ButtonObserver</a>
 and all the <tt>Button</tt> devices, since they are already <em>Observable</em>;</li>
 <li>we can reuse our concrete <tt>Led</tt> devices. The only thing to do is to introduce a 
 <a href="../src/main/java/it/unibo/blsFramework/concreteDevices/LedObserver.java" target="code">LedObserver</a>
 as an <a href="https://en.wikipedia.org/wiki/Adapter_pattern">adapter</a> between the 
<a href="../src/main/java/it/unibo/blsFramework/models/LedModel.java" target="code">LedModel</a> a concrete <tt>Led</tt>;</li>
 <li>we can also reuse the application logic 
<a href="../src/main/java/it/unibo/blsFramework/applLogic/BlsApplicationLogic.java" target="code">BlsApplicationLogic</a> 
with little change, since it must make reference to a 
<a href="../src/main/java/it/unibo/blsFramework/interfaces/ILedModel.java" target="code">ILedModel</a> rather than  to a 
<a href="../src/main/java/it/unibo/bls/interfaces/ILed.java" target="code">ILed</a>.</li>
 
 </ul>

 <h4>An example</h4>
 An example of its usage is given in  
<a href="../src/main/java/it/unibo/blsFramework/appl/MainBlsFramework.java" target="code">MainBlsFramework</a>.


 <h2>The Application Logic</h2> 
 
 In this work, rather than simply reusing our previous <tt>Java</tt> version of the component that implements the application logic,
 we will introduce a version based on <tt>Kotlin</tt>
 (<a href="../src/main/kotlin/it/unibo/blsFramework/kotlin/applLogic/BlsApplicationLogic.kt" target="code">BlsApplicationLogic.kt</a>), 
 by starting from the given requirement that it must work as a <em>proactive/reactive</em> entity:

<ul>
<li><em>reactive</em>: the application logic is always able to run the operation <bc>execute</bc>, since this operation is 
the method of a conventional object (the method code runs in the context of a caller<tt>Thread</tt>); </li>
<li><em>proactive</em>: the application logic is able to perform the 'blinking task' in autonomous way, until
the <tt>Button</tt> is pressed again.

</li>
</ul>

As done in <a href="../src/main/java/it/unibo/blsFramework/applLogic/BlsApplicationLogic.java" target="code">BlsApplicationLogic.java</a>,
the <a href="../src/main/kotlin/it/unibo/blsFramework/kotlin/applLogic/BlsApplicationLogic.kt" target="code">BlsApplicationLogic.kt</a>)
is a conventional <tt>Java</tt> class that exposes the method  <bc>execute</bc>.

<h4>The proactive part</h4>
The difference consists in implementing the 'proactive' part as a <em>Kotlin Actor</em> defined as follows:


<pre>
    protected var led: ILedModel? = null
    protected var doBlink        = false
	 
    val actorBlink = GlobalScope.actor<String>(dispatcher, 1 ) {
        for( msg in channel ) {
            //println("   ACTOR actorBlink |  msg= $msg doBlink= $doBlink ")
            while ( doBlink ) { //switch the led            
                if ( led!!.getState() ) led!!.turnOff() else led!!.turnOn()
                Utils.delay(250)
            }
         }
    }
</pre> 
 
The actor blinks the <tt>Led</tt> while the boolean variable <bc>doBlink</bc> is true. Otherwise it checks for a new message from its
input channel; if no message is present, the actor waits (more precisely, it <em>suspends</em>, since it is a coroutine) without consuming
<tt>CPU</tt> time.

<h4>The reactive part</h4>
The variable <bc>doBlink</bc> is changed by the method <bc>applLogic</bc> (called by the method <bc>execute</bc>)
that sends also a message to the actor, in order to resume its activity.

<pre>
   open  fun applLogic( ){  //open : can be overridden
        numCalls++
        doBlink = numCalls % 2 != 0     //if false actorBlink ends its loop
        println("	BlsFrameworkApplicationLogicKt | execute numCalls=$numCalls doBlink=$doBlink")
        if( doBlink )
        GlobalScope.launch {
            actorBlink.send("work") //REACTIVATES the actor
        }
    }
</pre> 

 <h3>(KOTLIN) ACTORS</h3> 
For an introduction to the concept of actor in Kotlin, see 
<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/shared-mutable-state-and-concurrency.md#actors" target="web">
Kotlin corotines: Shared mutable state and concurrency</a>.  Here we read that
 
"<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/shared-mutable-state-and-concurrency.md#actors" target="web">Kotlin actor</a>
is a coroutine builder  <i>'that conveniently combines actor's mailbox channel into its scope to receive messages from and 
combines the send channel into the resulting job object'</i>." 


From now on, we will represent such a new computational entity with the
following picture:

 <center><img src="./actor.png" alt="actor" width="10%" height="10%"></center>

 
 <h2>THE NEW FEATURES</h2>
The main result of our model-based re-factoring of the <tt>BLS</tt> system can be summarized as follows:

<ul>
<li>We can deploy the framework as a 'stand-alone', tested system (e.g. by providing a library as a <tt>JAR</tt> file). </li>
<li>We can build a <tt>BLS</tt> application by simply injecting in the framework some (new) specific, concrete device.</li>
<li>We can modify the application logic by overriding the <bc>appLogic</bc> method. </li>
<li>We can dynamically extend the system by adding more concrete buttons and led.</li>
</ul>

<h2>DYNAMIC EXTENSIONS</h2>
Of course, the consequence of dynamic extensions must be carefully analyzed before allowing them, but in some
applications can be appropriate and useful. 
<br/><br/>
For example, we could:
<ol>
<li><em>START</em>: start a system by introducing a 
<a href="../src/main/java/it/unibo/bls/devices/gui/LedAsGui.java" target="code">LedAsGui</a> and
a <a href="../src/main/java/it/unibo/bls/devices/gui/ButtonAsGui.java" target="code">ButtonAsGui</a>.</li>
<li><em>ADD</em>: after some time add a <a href="../src/main/java/it/unibo/bls/devices/arduino/LedProxyArduino.java" target="code">LedProxyArduino</a>,
and a <a href="../src/main/java/it/unibo/bls/devices/arduino/ButtonProxyArduino.java" target="code">ButtonProxyArduino</a> as defined
in our previous <a href="Lab2.html" target="info">Lab2.html</a>.
</li>
<li><em>CHANGE</em>: set up <a href="../src/main/kotlin/it/unibo/blsFramework/kotlin/applLogic/AnotherApplLogic.kt" target="code">AnotherApplLogic.kt</a></li>
</ol>
 
<pre>
public static void main(String[] args) {
		IBlsFramework blSystem = MainBlsFramework.createTheSystem("BLS-blink");
	//START:      Inject the concrete GUI devices		
		blSystem.setConcreteLed( LedAsGui.createLed() );
		blSystem.addConcreteButton( ButtonAsGui.createButton("LedControl") );
		Utils.delay(10000);	
	//ADD:        CHANGE THE SYSTEM DYNAMICALLY BY ADDING AN ARDUINO LED / BUTTON
        blSystem.addConcreteLed(LedProxyArduino.create(
			DeviceConfig.serialPortNum, DeviceConfig.serialBaudrate));
	    blSystem.addConcreteButton( new ButtonProxyArduino(
			DeviceConfig.serialPortNum, DeviceConfig.serialBaudrate));
		Utils.delay(10000);
	//CHANGE:    THE SYSTEM DYNAMICALLY BY ADDING AN ARDUINO LED
 		Utils.delay(5000);
		System.out.println(" ============ CHANGE CONTROL =============== ");
 		blSystem.setApplLogic (  new AnotherApplLogic() );
	}
</pre>
  
 <h2>TESTING / JaCoCo</h2>
A possible integration test is reported in
	<a href="../src/test/java/it/unibo/bls/integration/TestBlsFramework.java" target="code">TestBlsFramework.java</a>
<br/>
Execute <bc>gradle test</bc> and look at 
	<a href="../build/reports/tests/test/index.html" target="code">build/report/tests/test/index.html</a>	
	
	
<h3>JaCoCo</h3>
<ol>
<li>In <a href="../build.gradle" target="code">build.gradle</a> add the 
<a href="https://docs.gradle.org/current/userguide/jacoco_plugin.html" target="webb">JaCoCo plugin</a> 
(see <a href="https://www.youtube.com/watch?v=ieYs0hkogVY">Video on JaCoCo</a>)</li>
<li>The command <bc>gradle build</bc> does execute the tests and <tt>JaCoCo</tt> creates the binary file <bc>text.exec</bc> in <tt>build/jacoco</tt></li>

<li>Execute <bc>gradle build jacocoTestReport</bc> to convert the binary file a readable test report; then look at
<a href="../build/reports/jacoco/test/html/index.html" target="code">build/reports/jacoco/test/html/index.html</a>.

</li>
</ol>


 <h2>DEPLOYMENT</h2>
Executing <bc>gradle jar</bc> and look at <tt>build/libs</tt> for
<a href="../build/libs/it.unibo.bls19Local-1.0.jar" target="code">it.unibo.bls19Local-1.0.jar</a>.

<h2>WORK TO DO</h2>

Using the library <a href="../build/libs/it.unibo.bls19Local-1.0.jar" target="code">it.unibo.bls19Local-1.0.jar</a>, build a software
system with a single <tt>GUI Button</tt> that blinks a <tt>GUI Led</tt> on the PC and a <tt>Led</tt> on Arduino.




<br/><br/>


</div>  

</body>
</html>