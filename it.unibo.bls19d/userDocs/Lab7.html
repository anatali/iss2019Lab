<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
<!--

body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin: 10;
    margin-right: 15px;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
    border-bottom: 1px solid #242424;
}

h1 {
    font-size: 150%;
    background-color: #b2c0ff;
}

h2 {
    background-color: #d9fbff;
    font-size: 110%;
}

h3 {
	background-color: #e6ccff;
    font-size: 80%;
}
h4 {
    background-color: #99ffcc;
    font-size: 100%;
	width: 750px;
}
#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 80%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #ccffff;
    color: #0033cc;
}
bc{
	font-family: "Arial";
	font-size: 80%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
pre{
	font-family: "Helvetica";
	font-size: 70%;
	background-color: #fcf8c7; 
}
div.body{
	width: 800px;
    font-size: 18px;
}    
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}    
div.remark{
	background-color: #FFFC33;     
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}  
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}

  -->
</style>
    
<head>
   
<title>Lab7ISS</title></head>
    
<body>

<div class="body"> 

<h1>72939 - LAB7 | The QActor metamodel</h1> 
<a href="http://infolab.ingce.unibo.it/iss2018/it.unibo.issMaterial/issdocs/Material/LectureBologna1819.html" target="isslm">LabSS-lectures site</a></font> 

  


<h2><a id="metamodel"/>The metamodel </h2>
<em>QActor</em> is the name given to the custom meta-model inspired to the actor model, as supported by the <bc>Akka</bc> library.
<br/><br/>
The leading <em>Q/q</em> in the <tt>QActor</tt> word, means 'quasi' since the <tt>QActor</tt> meta-model does introduce (with respect to <tt>Akka</tt>) 
its own peculiarities, including reactive actions, even-driven programming concepts and a support for distribution in heterogeneous systems. 
<br/>
The addition of a <em>k</em> to the prefix (e.g. <bc>qak, Qak</bc>) means that we are making reference to the version implemented in <bc>Kotlin</bc>.
<br/><br/>
Let us summarize the main features of a <tt>qa-system</tt>:

<ul>
<li>A <em>QA-System</em> is a collection of active entities (<tt>QActors</tt>) each working in a computational node (<tt>Context</tt>). 
A QActor can interact with other <tt>QActors</tt> using <a href="#messages">Messages</a> of different types (<tt>Dispatch,
Request, Invitation, ...</tt>) and <a href="#events">Events</a>.</li>
 
<li>The <em>configuration</em> of a <tt>QA-System</tt> is explicitly represented by a set of 'facts' written in tuProlog syntax
replicated in each <tt>Context</tt> (Context Knowledge Base or simply <em>ContextKB</em>). A <tt>QA-System</tt>
con be configured in a static or in a dynamic way. In case of dynamic configuration, the knowledge about
the configuration is dynamically updated in each <tt>Context</tt> of the system .
</li>

<li>The <em>start-up</em> of a distributed <tt>QA-System</tt> (i.e. a system made of two or more Contexts) is handled by
the run-time support. In particular, the Application code (i.e. the code written into the actors) begins to
run only when all the <tt>Contexts</tt> are activated.
</li>
<li>The <em>exchange of information</em> among the <tt>QActors</tt> is implemented by the <bc>QA-Infrastructure</bc>.
 The <tt>QA-Infrastructure</tt> supports interaction among <tt>QActors</tt
working in the same <tt>Context</tt> and/or in different Contexts. In the latter case, the <tt>QA-Infrastructure</tt>
exploits the <tt>ContextKB</tt> in order to deliver a message from the <tt>Context</tt> of the sender to the Context of the
destination. An event raised in some <tt>Context</tt>, is delivered to all the other <tt>Contexts</tt> of the system.
</li>

<li>To <em>deliver information</em> among the Contexts, the <tt>QA-Infrastructure</tt> can use pairwise <tt>TCP</tt> connections
between the <tt>Contexts</tt> or a <bc>MQTT</bc> broker. The choice is up to the Application designer.</li>

<li>Each <tt>QActor</tt> <em>behaves</em> as a (Moore's) Finite State Automaton (<tt>FSM</tt>). 
While in a state, a <tt>QActor</tt> can execute
both synchronous and asynchronous actions. An asynchronous action terminates immediately and emits
an event when it terminates.
</li>

<li>A <tt>QActor</tt> is able to execute a set of pre-defined actions:
<ul>

</ul>
</li>

<li>A <tt>QActor</tt> is associated to a <em>private knowledge-base</em> (<bc>QaKB</bc>) written in <tt>Prolog</tt> that can be
dynamically extended by the Application Designer.</li>
</ul>

<h3 id="messages">Messages</h3>
In the QActor metamodel, a message is intended as information sent in asynchronous way by some source to
some specific destination.
<br/><br/>
For </bc>asynchronous</bc> transmission we intend that the messages can be 'buffered' by the infrastructure,
while the 'unbuffered' transmission is said to be <bc>synchronous</bc>.
 <br/><br/>
A message does not force the execution of code: a message <tt>m</tt> sent from an actor sender to an actor receiver
can trigger a state transition in the receiver. If the receiver is not 'waiting' for a
transition including <tt>m</tt> the message is enqueued in the receiver queue.
<br/><br/>
At application-level, we say that a QActor works according to a <bc>message-based</bc> behaviour, while at the
lower level (in the infrastructure) it works according to the <bc>massage-driven</bc> behaviour.
 

<h3 id="events">Events</h3>
In the QActor metamodel, an event is intended as information emitted by some source without any explicit
destination. Events can be emitted by the QActors that compose a actor-system or by sources external to the
system.
<br/><br/>
The occurrence of an event can put in execution some code devoted to the management of that event. We
qualify this kind of behaviour as event-driven behaviour, since the event 'forces' the execution of code.
<br/><br/>
An event can also trigger state transitions in components, usually working as Finite state machines. We
qualify this kind of behaviour as <bc>event-based</bc> behaviour, since the event is 'lost' if no actor is in a state
waiting for it.


<h2 id="prodcons">A Producer-Consumer system</h2>
Let us consider the following problem:
<div class="req">
Design and build a <tt>Distributed</tt> software system made of <tt>np, np>=1</tt> actors that work as information <em>Producer</em> 
and <tt>nc, nc>=1</tt> that work as information <em>Consumer</em>. A producer must produce a sequence of <bc>DataItem</bc> objects, with:
<pre>
data class  DataItem( val item: String, val id : String = "dataItem" ){}
</pre>   

<hr/> 
<b>User story</b><br/>
 As a <bc>end user</bc>, I want to have the ability :
 <ol>
<li><em>start</em>: to activate one producer and one or more consumers. 
The <tt>DataItem</tt> generated by the producer must be received by all the consumers;</li>
<li><em>log</em>: to store each item received by each consumer into a resource named <bc>EventLog</bc>;</li>
<li><em>show</em>: to show all the data stored in <tt>EventLog</tt>;</li>
<li><em>addConsumer</em>: to dynamically add a new consumer to the system.</li>
 </ol>
</div>

<h3 id="yield">Problem analysis</h3>

<h4 id="kprod">Using a Kotlin Producer</h4>
<tt>Kotlin</tt> does introduce a built-in concept of <bc>Producer</bc> as an entity associated to a
<bc>ReceiveChannel<T></bc>
(see <a href="../../it.unibo.bls19Local/userDocs/Lab4.html#producer" target="code">Lab4.html#producer</a>).

The coroutine builder <bc>produce</bc> takes a suspending lambda as a parameter and only the code within 
this lambda can send items to the channel.
The channel has no buffer by default is closed when the coroutine completes


<center><table style="width:98%">
<tbody>	

<tr>
<td style="width:45%">
<h5>A simple case</h5>
<pre>
val simpleProducer : ReceiveChannel<Int> =
            GlobalScope.produce {
    for( i in 1..3 ){
        println( "simpleProducer produces $i")
        send( i )
    }
}

suspend fun consume(){
    val v = simpleProducer.receive()
    println( "consume receives ${v} in ${sysUtil.curThread()}" )
    simpleProducer.consumeEach {
      println( "consume receives $it in ${sysUtil.curThread()}" )
    }
}

</pre>
</td>
<td>
<m>The full code is in <a href="../src/main/kotlin/it/unibo/qak/prodConsKotlin/simpleProducerKotlin.kt" target="code">simpleProducerKotlin.kt</a>.
<br/>The output is:</m>
<pre>
simpleProducer produces 1 in thread=DefaultDispatcher-worker-2
simpleProducer produces 2 in thread=DefaultDispatcher-worker-2
consume receives 1 in thread=main
simpleProducer produces 3 in thread=DefaultDispatcher-worker-2
consume receives 2 in thread=main
consume receives 3 in thread=main
BYE
</pre>
<m>If we omit to call <bc>consume()</bc>, the output is:</m>
<pre>
BYE
</pre>
</td>
</tr>

<tr>
<td>
<h5>A many-type producer</h5>
<pre>
val context = newSingleThreadContext("myThread")

val producer: ReceiveChannel<Any> =
    GlobalScope.produce(context, 1){
        println( "producer sends 5   in ${sysUtil.curThread()}")
        send(5)
        println( "producer sends a   in ${sysUtil.curThread()}")
        send("a")
        println( "producer sends 100 in ${sysUtil.curThread()}")
        send(100)
    }

suspend fun consumer(){
 val v = producer.receive()
 println( "consumer receives $v in ${sysUtil.curThread()}")
 producer.consumeEach { 
  println( "consumer receives $it in ${sysUtil.curThread()}")}
}
</pre>
</td>
<td>
<m>The full code is in <a href="../src/main/kotlin/it/unibo/qak/prodConsKotlin/prodConsKotlin.kt" target="code">prodConsKotlin.kt</a>.<br/>
When channel <bc>capacity = 1</bc>, the output is:</m>
<pre>
producer sends 5   in thread=myThread
consumer receives 5 in thread=main
producer sends a   in thread=myThread
producer sends 100 in thread=myThread
consumer receives a in thread=main
consumer receives 100 in thread=main
BYE
</pre>
<m>When channel <bc>capacity = 3</bc>, the output is:</m></m>
<pre>
producer sends 5   in thread=myThread
producer sends a   in thread=myThread
producer sends 100 in thread=myThread
consumer receives 5 in thread=main
consumer receives a in thread=main
consumer receives 100 in thread=main
BYE
</pre>
</td>
</tr>

<tr>
<td style="width:45%">
<h5>Many consumers</h5>
<pre>
val aProducer : ReceiveChannel<Int> = GlobalScope.produce{
    for( i in 1..3 ){
        println( "aProducer produces $i in ${sysUtil.curThread()}")
        send( i )
    }
}

fun consumer1(scope: CoroutineScope){
 scope.launch{
	delay(100)
	val v = aProducer.receive()
	println( "consumer1 receives ${v} in ${sysUtil.curThread()}" )
 }
}
fun consumer2(scope: CoroutineScope){
 scope.launch{
	for( i in 1..2 ) {
	  val v = aProducer.receive()
	  println("consumer2 receives ${v} in ${sysUtil.curThread()}")
	  delay(100)
	}
 }
}
</pre>
</td>
<td>
<m>The full code is in <a href="../src/main/kotlin/it/unibo/qak/prodConsKotlin/prodManyConsKotlin.kt" target="code">prodManyConsKotlin.kt</a>.
<br/>The output is:</m>
<pre>
BYE
aProducer produces 1 in thread=DefaultDispatcher-worker-1
consumer2 receives 1 in thread=main
aProducer produces 2 in thread=DefaultDispatcher-worker-1
consumer1 receives 2 in thread=main
aProducer produces 3 in thread=DefaultDispatcher-worker-1
consumer2 receives 3 in thread=main
</pre>
 
</td>
</tr>

</tbody>	
</table></center>

<br/>
<!-- <div class="remark"></div> -->
The problem is that our consumers must work on different nodes and could be written in languages different from <tt>Kotlin</tt>.




<h4 id="yield">Producer as a Kotlin suspendable sequence</h4>

Kotlin  introduces the concept of <bc>suspendable sequence</bc> i.e.
a coroutine builder that can <i>suspend between invocation</i> by using the <bc>yield()</bc> function (see
<a href="../../it.unibo.bls19Local/userDocs/Lab4.html#yield" target="code">Lab4.html#yield</a>).
<br/><br/>
We could define a producer-consumer system based on suspendable sequence
<br/><br/>

<center><table style="width:98%">
<tbody>	

<tr>
<td style="width:45%">
<pre>
val seqProd  = sequence{
    var v = 1
    while(true){
        println( "seqProd produces $v in ${sysUtil.curThread()}")
        yield( v++ )
    }
}

suspend fun seqcons1( scope : CoroutineScope){
	println("seqcons1 STARTS")
    scope.launch {
        val vlist = seqProd.take(3).toList()
        println("seqcons1 receives $vlist in ${sysUtil.curThread()}")
    }
}

suspend fun seqcons2( scope : CoroutineScope ){
	println("seqcons2 STARTS")
    scope.launch {
        val vlist = seqProd.take(7).filter { it % 2 != 0 }.toList()
        println("seqcons2 receives $vlist in ${sysUtil.curThread()}")
    }
}

fun main() = runBlocking{
    seqcons1(this)
    seqcons1(this)
    println( "BYE")
}
</pre>
</td>
<td>
<m>The full code is in <a href="../src/main/kotlin/it/unibo/qak/prodConsKotlin/prodSequenceKotlin.kt" target="code">prodSequenceKotlin.kt</a>.
<br/>The <tt>OUTPUT</tt> is:</m>
<pre>
seqcons1 STARTS
seqcons2 STARTS
BYE
seqProd produces 1 in thread=main
seqProd produces 2 in thread=main
seqProd produces 3 in thread=main
seqcons1 receives [1, 2, 3] in thread=main
seqProd produces 1 in thread=main
seqProd produces 2 in thread=main
seqProd produces 3 in thread=main
seqProd produces 4 in thread=main
seqProd produces 5 in thread=main
seqProd produces 6 in thread=main
seqProd produces 7 in thread=main
seqcons2 receives [1, 3, 5, 7] in thread=main
</pre>
</td>
</tr>

 
</tbody>	
</table></center>

<br/>
The problem is that our producer does not recompute the values when needed by the consumers.

<h4 id="yield">Producer as event emitter</h4>


<h2>...</h2>
<center><table style="width:98%">
<tbody>	

<tr>
<td style="width:45%">
<pre>
</pre>
</td>
<td>
</td>
</tr>
</tbody>	
</table></center>
 

 
</tbody>	
</table></center>

 

 

</p>
<!--
 <h2>BLSD7Segm (Work to do)</h2>
 <div class="req">
Design and build a <tt>Distributed</tt> software system in which
<ul>
<li>A </li>
<li>shows the value on <bc>Seven-Segment Display</bc>
</li>
</ul>
-->

 
</div>	 


</div>  
<div style="background-color:rgba(86, 56, 253, 0.9); width:100%;text-align:center;font-size:small;color:white">
By AN Unibo-DISI    
</div> 
</body>
</html>