<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
<!--

body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin: 10;
    margin-right: 15px;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
    border-bottom: 1px solid #242424;
}

h1 {
    font-size: 150%;
    background-color: #b2c0ff;
}

h2 {
    background-color: #d9fbff;
    font-size: 110%;
}

h3 {
	background-color: #e6ccff;
    font-size: 80%;
}
h4 {
    background-color: #99ffcc;
    font-size: 100%;
	width: 750px;
}
#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 80%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #ccffff;
    color: #0033cc;
}
bc{
	font-family: "Arial";
	font-size: 80%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
pre{
	font-family: "Helvetica";
	font-size: 80%;
	background-color: #fcf8c7;
	border: 1px solid blue;
	width: 700px;
}
div.body{
	width: 800px;
    font-size: 18px;
}    
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}    

table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}

  -->
</style>
    
<head>
   
<title>Lab6ISS</title></head>
    
<body>

<div class="body"> 

<h1>72939 - LAB6 | Towards distributed systems</h1> 
<a href="http://infolab.ingce.unibo.it/iss2018/it.unibo.issMaterial/issdocs/Material/LectureBologna1819.html" target="isslm">LabSS-lectures site</a></font> 

<h2>WORKPLAN (REQUIREMENTS)</h2>

<ol>
<li><em>BLSDSingle</em>: Design and build a <tt>Distributed</tt> software system with one <tt>Button</tt> and one <tt>Led</tt>.</li>
<li><em>BLSDChain</em>: Design and build a <tt>Distributed</tt> software system   with one <tt>Button</tt> and a 
<em>chain of Led</em> made of <tt>n>2</tt>:
<a href="../../it.unibo.bls19Local/src/main/kotlin/it/unibo/chain/segment7/LedSegment.kt" target="code">LedSegment.kt</a>.</li>
<li><em>BLSD7Segm</em>: Design and build a <tt>Distributed</tt> software system that updates a <tt>7-segment display</tt>.</li>
</ol>

<h2>BLSDSingle </h2> 
Our starting point is the system of <a href="Lab5.html" target="code">Lab5.html</a>

<center><img src="./blsActorkA.png" alt="blsActorkA" width="60%" height="60%"></center>

<h3>Problem analysis</h3>

<ol>
<li>Since there are <tt>3</tt> components, how many computational nodes are appropriate: two or three?</li>
<li>In order to <bc>reduce costs</bc>, the <bc>customer</bc> has fixed to <tt>2</tt> the number of computational nodes. Now the problem is: which node
is more appropriate for the <tt>Control</tt>: the node of the <tt>Button</tt> or the node of the <tt>Led</tt>?
If we want to <bc>minimize network traffic</bc>, it is more appropriate to put <tt>Control</tt> and  <tt>Led</tt> on the same node.
<br/><br/>
<center><img src="./blsActorkB.png" alt="blsActorkB" width="60%" height="60%"></center>


</li>
<li>Do we have appropriate technology for implementing  <i>exchange of information</i> among different computational nodes? Of course, the answer
is positive, with many possible choices, mainly related to the usage of  <em>communication protocols</em>:
	<ul>
		<li><bc>UDP, TCP</bc></li>
		<li><bc>Bluetooth</bc></li>
		<li><bc>HTTP</bc></li>
		<li><bc>CoAP</bc> : 
		see <a href="https://en.wikipedia.org/wiki/Constrained_Application_Protocol" target="web">Constrained Application Protocol</a>
		</li>
		<li><bc>MQTT</bc> : 
		see <a href="https://en.wikipedia.org/wiki/MQTT" target="web">Message Queuing Telemetry Transport</a>
		</li>
		<li>...</li>
	</ul>
Now the problem is about the possibility to design and build our software system, so to minimize the impact of changes in the case we want 
to change the communication protocol.
</li>
<li>The <a href="https://en.wikipedia.org/wiki/Proxy_pattern" target="web">proxy design pattern</a>  cna be taken as a reference point
for the required modifications in our system architecture:

<center><img src="./blsActorkDistr.png" alt="blsActorkDistr" width="80%" height="80%"></center>

</li>
</ol>

<h2>CODE </h2>

<center><table style="width:98%">
<tbody>	

<tr>
<td style="width:25%">
<a href="../src/main/kotlin/it/unibo/bls19d/qak/SystemKb.kt" target="code">SystemKb.kt</a>
</td>
<td><m>As done in <a href="Lab5.html" target="code">Lab5.html</a>, it defines a singleton
 <bc>Map&lt;String, ActorBasic></bc>  that allows us to get (the reference to) an actor by knowing the (unique) name of the actor. 
 Moreover, it defines the <bc>portNumber</bc> of the 
 <a href="../src/main/kotlin/it/unibo/bls19d/qak/distr/ServerControl.kt" target="code">ServerControl.kt</a>.

 </m>
</td>
</tr>


<tr>
<td> 
<a href="../src/main/kotlin/it/unibo/bls19d/qak/ButtonActork.kt" target="code">ButtonActork.kt</a>
</td>
<td> 
<m>The same introduced in <a href="Lab5.html" target="code">Lab5.html</a> 
</m>
 </td>
</tr>

<tr>
<td> 
<a href="../src/main/kotlin/it/unibo/bls19d/qak/ControlActork.kt" target="code">ControlActork.kt</a>
</td>
<td> 
<m>The same introduced in <a href="Lab5.html" target="code">Lab5.html</a> 
</m>
 </td>
</tr>

<tr>
<td> 
<a href="../src/main/kotlin/it/unibo/bls19d/qak/LedActork.kt" target="code">LedActork.kt</a>
</td>
<td> 
<m>The same introduced in <a href="Lab5.html" target="code">Lab5.html</a> 
</m>
 </td>
</tr>


<tr>
<td style="width:25%">
<a href="../src/main/kotlin/it/unibo/bls19d/qak/distr/MainBlsDistrNode1.kt" target="code">MainBlsDistrNode1.kt</a>
</td>
<td><m>Creates the system components running on the first node, i.e. 
<ul>
<li>the  button (<a href="../src/main/kotlin/it/unibo/bls19d/qak/ButtonActork.kt" target="code">ButtonActork.kt</a>)</li>
<li>the proxy to the remote control 
(<a href="../src/main/kotlin/it/unibo/bls19d/qak/distr/ProxyControl.kt" target="code">ProxyControl.kt</a>)</li>
</ul>
The main builds the <tt>ButtonActork</tt> by giving to it the name of the proxy, so that the button
will convert a <tt>"click"</tt> into a <bc>BlsCmds.ButtonCmd()</bc> object sent to the proxy (instead to the
control actor as done in <a href="Lab5.html" target="code">Lab5.html</a> ).

</m>
</td>
</tr>

<tr>
<td style="width:25%">
<a href="../src/main/kotlin/it/unibo/bls19d/qak/distr/MainBlsDistrNode2.kt" target="code">MainBlsDistrNode2.kt</a>
</td>
<td><m>Creates the system components running on the first node, i.e. 
<ul>
<li>the led (<a href="../src/main/kotlin/it/unibo/bls19d/qak/LedActork.kt" target="code">LedActork.kt</a>)</li>
<li>the control (<a href="../src/main/kotlin/it/unibo/bls19d/qak/ControlActork.kt" target="code">ControlActork.kt</a>) </li>
<li>the server (<a href="../src/main/kotlin/it/unibo/bls19d/qak/ServerControl.kt" target="code">ServerControl.kt</a>) 
that accepts commands for the control.</li></ul>

 </m>
</td>
</tr>


<tr>
<td>
<a href="../src/main/kotlin/it/unibo/bls19d/qak/distr/ProxyControl.kt" target="code">ProxyControl.kt</a></td>
<td><m>At construction time, the proxy attempts to connect itself with the remote
<a href="../src/main/kotlin/it/unibo/bls19d/qak/distr/ServerControl.kt" target="code">ServerControl.kt</a>.
<br/>
Then, it waits for an <a href="../src/main/kotlin/it/unibo/kactor/MsgUtil.kt" target="code">ApplMessage</a>
(with a <bc>BlsCmds.ButtonCmd()</bc> as content) and 'redirects' such a message to the connected server. </m>
</td>
</tr>

<tr>
<td>
<a href="../src/main/kotlin/it/unibo/bls19d/qak/distr/ServerControl.kt" target="code">ServerControl.kt</a></td>
<td><m>At construction time, the server receives the name of the 
<a href="../src/main/kotlin/it/unibo/bls19d/qak/LedActork.kt" target="code">LedActork.kt</a>;
then its sends to itself a <bc>"start"</bc> message in order to start its works, that consists
in waiting for a connection request (from the proxy).
When a new connection is set, the server waits for an 
<a href="../src/main/kotlin/it/unibo/kactor/MsgUtil.kt" target="code">ApplMessage</a> that itswitches to the control.

<br/><br/>
All the work of the server is done within the same coroutine, since we no do expect more than one connection.
</m>
</td>
</tr>



</tbody>	
</table></center>

<h2>THE <bc>IConnInteraction</bc> INTERFACE </h2>

 




 
 
	<br/><br/> 
</div>  

</body>
</html>