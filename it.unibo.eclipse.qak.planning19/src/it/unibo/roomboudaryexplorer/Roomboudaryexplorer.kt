/* Generated by AN DISI Unibo */ 
package it.unibo.roomboudaryexplorer

import it.unibo.kactor.*
import alice.tuprolog.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
	
class Roomboudaryexplorer ( name: String, scope: CoroutineScope ) : ActorBasicFsm( name, scope){
 	
	override fun getInitialState() : String{
		return "s0"
	}
		
	override fun getBody() : (ActorBasicFsm.() -> Unit){
		
		var mapEmpty    = false
		val mapname     ="roomBoundary"		//
		var Tback       = 0L
		var stepCounter = 0 
		var Curmove     = ""
		var Direction   = "" 
		var MaxX        = 0
		var MaxY        = 0
		var CurX        = 0
		var CurY        = 0
		var GX          = 0
		var GY          = 0
		var TableFound  = false
		var curmoveIsForward = false
		var endTableEdge = false
		var NunOfTurn       = 0
		var NumStep      = 0
		
		//var StepTime   = 1000L	//long		/ 
		////var RotateTime = 610L	//long		//300L	//for virtual
		//var PauseTime  = 500L 
		
		var StepTime   = 330L	//for virtual
		var RotateTime = 300L	//for virtual
		var PauseTime  = 500L 
		
		
		return { //this:ActionBasciFsm
				state("s0") { //this:State
					action { //it:State
						println("&&&  planex0 STARTED")
						solve("consult('moves.pl')","") //set resVar	
						itunibo.planner.plannerUtil.initAI(  )
						println("INITIAL MAP")
					}
					 transition( edgeName="goto",targetState="detectBoundary", cond=doswitch() )
				}	 
				state("detectBoundary") { //this:State
					action { //it:State
						NumStep++
						itunibo.planner.plannerUtil.showMap(  )
					}
					 transition( edgeName="goto",targetState="doAheadMove", cond=doswitchGuarded({(NumStep<5)}) )
					transition( edgeName="goto",targetState="boundaryFound", cond=doswitchGuarded({! (NumStep<5)}) )
				}	 
				state("doAheadMove") { //this:State
					action { //it:State
						println("&&&  doAheadMove")
						forward("onestep", "onestep($StepTime)" ,"onestepahead" ) 
					}
					 transition(edgeName="t00",targetState="stepDone",cond=whenDispatch("stepOk"))
					transition(edgeName="t01",targetState="stepFailed",cond=whenDispatch("stepFail"))
				}	 
				state("stepDone") { //this:State
					action { //it:State
						itunibo.planner.plannerUtil.doMove( "w"  )
						itunibo.planner.plannerUtil.showMap(  )
						delay(PauseTime)
					}
					 transition( edgeName="goto",targetState="doAheadMove", cond=doswitch() )
				}	 
				state("reachWallRight") { //this:State
					action { //it:State
						itunibo.planner.plannerUtil.showMap(  )
					}
					 transition( edgeName="goto",targetState="doAheadMove", cond=doswitch() )
				}	 
				state("stepFailed") { //this:State
					action { //it:State
						println("&&&  FOUND WALL")
						println("$name in ${currentState.stateName} | $currentMsg")
						if( checkMsgContent( Term.createTerm("stepFail(R,T)"), Term.createTerm("stepFail(Obs,Time)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								Tback=payloadArg(1).toString().toLong() / 3 
								println("stepFailed ${payloadArg(1).toString()}")
						}
						forward("modelChange", "modelChange(robot,s)" ,"resourcemodel" ) 
						delay(Tback)
						forward("modelChange", "modelChange(robot,h)" ,"resourcemodel" ) 
						itunibo.planner.plannerUtil.wallFound(  )
						forward("modelChange", "modelChange(robot,a)" ,"resourcemodel" ) 
						forward("modelChange", "modelChange(robot,h)" ,"resourcemodel" ) 
						itunibo.planner.plannerUtil.doMove( "a"  )
						delay(PauseTime)
					}
					 transition( edgeName="goto",targetState="detectBoundary", cond=doswitch() )
				}	 
				state("boundaryFound") { //this:State
					action { //it:State
						println("FINAL MAP")
						itunibo.planner.plannerUtil.showMap(  )
						itunibo.planner.plannerUtil.saveMap( mapname  )
					}
				}	 
			}
		}
}
