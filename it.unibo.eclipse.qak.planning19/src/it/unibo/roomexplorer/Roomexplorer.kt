/* Generated by AN DISI Unibo */ 
package it.unibo.roomexplorer

import it.unibo.kactor.*
import alice.tuprolog.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
	
class Roomexplorer ( name: String, scope: CoroutineScope ) : ActorBasicFsm( name, scope){
 	
	override fun getInitialState() : String{
		return "s0"
	}
		
	override fun getBody() : (ActorBasicFsm.() -> Unit){
		
		var mapEmpty  = false
		var Tback      = 0L
		var stepCounter = 0 
		var Curmove = ""
		var curmoveIsForward = false
		
		//var StepTime   = 1000L	//long		/ 
		////var RotateTime = 610L	//long		//300L	//for virtual
		//var PauseTime  = 500L 
		
		var StepTime   = 330L	//for virtual
		var RotateTime = 300L	//for virtual
		var PauseTime  = 500L 
		
		var Direction = "" 
		return { //this:ActionBasciFsm
				state("s0") { //this:State
					action { //it:State
						solve("consult('moves.pl')","") //set resVar	
						itunibo.planner.plannerUtil.initAI(  )
						itunibo.planner.moveUtils.loadRoomMap(myself)
						solve("mapdims(X,Y)","") //set resVar	
						mapEmpty = ( getCurSol("X").toString() == "0")
					}
					 transition( edgeName="goto",targetState="exploreBoundary", cond=doswitchGuarded({mapEmpty}) )
					transition( edgeName="goto",targetState="findTable", cond=doswitchGuarded({! mapEmpty}) )
				}	 
				state("exploreBoundary") { //this:State
					action { //it:State
						println("MAP AT START")
						itunibo.planner.plannerUtil.showMap(  )
						solve("direction(D)","") //set resVar	
						println("DIRECTION: ${getCurSol("D").toString()}")
					}
					 transition( edgeName="goto",targetState="moveAhead", cond=doswitch() )
				}	 
				state("moveAhead") { //this:State
					action { //it:State
						itunibo.planner.moveUtils.doPlannedMove(myself ,"w" )
						itunibo.planner.plannerUtil.startTimer(  )
						forward("onestep", "onestep($StepTime)" ,"onecellforward" ) 
						delay(PauseTime)
					}
					 transition(edgeName="t00",targetState="moveAhead",cond=whenDispatch("stepOk"))
					transition(edgeName="t01",targetState="changeDirection",cond=whenDispatch("stepFail"))
				}	 
				state("changeDirection") { //this:State
					action { //it:State
						forward("modelChange", "modelChange(robot,a)" ,"resourcemodel" ) 
						delay(RotateTime)
						forward("modelChange", "modelChange(robot,h)" ,"resourcemodel" ) 
						itunibo.planner.moveUtils.doPlannedMove(myself ,"a" )
						solve("direction(D)","") //set resVar	
						Direction = getCurSol("D").toString() 
						println("DIRECTION: ${getCurSol("D").toString()}")
						itunibo.planner.plannerUtil.showMap(  )
						itunibo.planner.plannerUtil.saveMap( "roomMap.txt"  )
					}
					 transition( edgeName="goto",targetState="endOfExploreBoubdary", cond=doswitchGuarded({(Direction=="downDir")}) )
					transition( edgeName="goto",targetState="moveAhead", cond=doswitchGuarded({! (Direction=="downDir")}) )
				}	 
				state("endOfExploreBoubdary") { //this:State
					action { //it:State
						println("EXPLORATION ENDS")
					}
				}	 
				state("findTable") { //this:State
					action { //it:State
						println("findTable START")
					}
				}	 
			}
		}
}
