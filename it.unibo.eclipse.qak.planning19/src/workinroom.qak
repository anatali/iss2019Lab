/*
* The robot plans a trip from home to the east part of the table
* and executes it.
*/
System workinroom  
mqttBroker "localhost" : 1883  

Dispatch modelChange  : modelChange( TARGET, VALUE )   

Dispatch onestep       : onestep(DURATION)
Dispatch stepOk        : stepOk(V)		//TODO eliminate  V
Dispatch stepFail      : stepFail(R,T) //R=ok | obstacle, T = time

Event  sonarRobot     : sonar( DISTANCE )	     //from  sonar on robot 

Context ctxWorkInRoom     ip [host="localhost" port=8038]    -mqtt 
Context ctxDummyForMind   ip [host="otherresourcelocalhost" port=8035]   -mqtt 

ExternalQActor resourcemodel context ctxDummyForMind 

QActor workerinroom context ctxWorkInRoom{     
["
var mapEmpty    = false
val mapname     =\"roomMapWithTable\"
var Tback       = 0L
var stepCounter = 0 
var Curmove     = \"\"
var Direction   = \"\" 
var MaxX        = 0
var MaxY        = 0
var CurX        = 0
var CurY        = 0
var GX          = 0
var GY          = 0
var TableFound  = false
var curmoveIsForward = false
var endTableEdge = false
var NunOfTurn       = 0

//var StepTime   = 1000L	//long		/ 
////var RotateTime = 610L	//long		//300L	//for virtual
//var PauseTime  = 500L 

var StepTime   = 330L	//for virtual
var RotateTime = 300L	//for virtual
var PauseTime  = 250L 


"]	 
	State s0 initial {	    
	    solve( consult("moves.pl")	 )
 		run itunibo.planner.plannerUtil.initAI()
  		run itunibo.planner.moveUtils.loadRoomMap( myself, mapname )	//assert mapdims/2   
// 		solve( mapdims(X,Y) )
// 		["mapEmpty = ( getCurSol(\"X\").toString() == \"0\")"]
 		//run itunibo.planner.plannerUtil.setObstacles()
// 		run itunibo.planner.plannerUtil.showMap()
 	} 
	Goto  tableEast
	 
	State tableEast{
 		run itunibo.planner.plannerUtil.setGoal(5,3)
  		run itunibo.planner.moveUtils.doPlan( myself )
 		solve( dialog(F) )
   	} 
	Goto executePlannedActions //doGoHomeActions 
		
  
	State executePlannedActions{ 
		//solve( showMoves ) 
		solve( retract( move(M) ) ) 
		ifSolved {  
			["Curmove = getCurSol(\"M\").toString() 
              curmoveIsForward=(Curmove == \"w\")
	        "]
		} else { ["Curmove = \"\"; curmoveIsForward=false"]  }  
		//println("executePlannedActions doing $Curmove")
 	}
	Goto checkAndDoAction  if "(Curmove.length>0) " else goalOk 

 	State goalOk{		  
  		run itunibo.planner.moveUtils.setPosition(myself)
 		solve( curPos(X,Y,D) )
["
CurX      = Integer.parseInt( getCurSol(\"X\").toString()  )  
CurY      = Integer.parseInt( getCurSol(\"Y\").toString()  )
Direction = getCurSol(\"D\").toString()
"]   		
		println("ON THE TARGET CELL: CurX=$CurX, CurY=$CurY, dir=$Direction")
		run itunibo.planner.plannerUtil.showMap()
		
 	}
  	
 	//Execute the move if it is a rotation or halt
	State checkAndDoAction{	 }
	Goto doForwardMove if "curmoveIsForward" else doTheMove
	
	State doTheMove{
//		if "Curmove==\"a\"" { forward resourcemodel -m modelChange : modelChange(robot,l) }
//		if "Curmove==\"d\"" { forward resourcemodel -m modelChange : modelChange(robot,r) }
//		run itunibo.planner.moveUtils.doPlannedMove(myself, Curmove)
  		forward resourcemodel -m modelChange : modelChange(robot,$Curmove) 
		delayVar RotateTime //rotate 
		forward resourcemodel -m modelChange : modelChange(robot,h) //stop
		run itunibo.planner.moveUtils.doPlannedMove(myself, Curmove)
 		delayVar PauseTime		
		//println("doTheMove DONE $Curmove")
 		//solve( dialog(F) )	//to CALIBRATE rotation time
	}
	Goto executePlannedActions 
	
	//Delegate a forward move to onecellforward
	State doForwardMove{
		run itunibo.planner.plannerUtil.startTimer()
		forward onecellforward -m onestep : onestep($StepTime)	
	}
	Transition t0   whenMsg stepOk   -> handleStepOk   
					whenMsg stepFail -> hadleStepFail 
 	
    	
	State handleStepOk{
		run itunibo.planner.moveUtils.doPlannedMove(myself, "w")	
		delayVar PauseTime	
	}
	Goto executePlannedActions
	
 	State hadleStepFail{ 
		println("NEVER HERE!!!")
	}
	
}	

/*
 * ====================================================================
 * onecellforward
 * ====================================================================
 */
QActor onecellforward context ctxWorkInRoom {
[" var foundObstacle = false; var StepTime = 0L"]  
	State s0 initial {	   
		["foundObstacle = false "]
	} 
	Transition t0 whenMsg onestep -> doMoveForward
	
	State doMoveForward{		  
		onMsg( onestep : onestep( TIME ) ) {
			["StepTime = payloadArg(0).toLong()"]
 			forward resourcemodel -m modelChange : modelChange(robot,w)
			run itunibo.planner.plannerUtil.startTimer()
		}
	} 
	Transition t0 whenTimeVar  StepTime -> endDoMoveForward		
 		          whenEvent sonarRobot  -> handleSonarRobot
		  
	State endDoMoveForward{
		forward resourcemodel -m modelChange : modelChange(robot,h)
		forward workerinroom -m stepOk : stepOk(ok)  //answer
	}
	Goto s0
	
	//Substitute with an ad-hoc actor for a real robot
	State handleSonarRobot{  //before than the step time
		run itunibo.planner.moveUtils.setDuration(myself)
		printCurrentMessage
 		onMsg ( sonarRobot : sonar( DISTANCE ) ){     
			["val distance = Integer.parseInt( payloadArg(0) ) 
              foundObstacle = (distance<20) "]  
   		}
	}
	Goto stepFail if "foundObstacle" else s0
	
	State stepFail{
		println("&&& onecellforward stepfail ")
		solve( wduration( TIME ) )
		forward workerinroom -m stepFail : stepFail(obstacle,#TIME)  	
	}
	Goto s0
}    

