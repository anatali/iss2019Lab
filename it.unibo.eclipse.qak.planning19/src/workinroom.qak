/*
* The robot plans a trip from home to the east part of the table
* and executes it.
*/
System workinroom  
mqttBroker "localhost" : 1883   

Dispatch modelChange  : modelChange( TARGET, VALUE )   
Dispatch modelUpdate  : modelUpdate( TARGET, VALUE )

Dispatch onestep       : onestep(DURATION)
Dispatch stepOk        : stepOk(V)		//TODO eliminate  V
Dispatch stepFail      : stepFail(R,T) //R=ok | obstacle, T = time

Event  sonarRobot     : sonar( DISTANCE )	     //from  sonar on robot 

Context ctxWorkInRoom     ip [host="localhost" port=8038]    -mqtt 
Context ctxDummyForMind   ip [host="otherresourcelocalhost" port=8035]   -mqtt 

ExternalQActor resourcemodel context ctxDummyForMind 
ExternalQActor onestepahead  context ctxDummyForMind

QActor workerinroom context ctxWorkInRoom{     
["
var mapEmpty    = false
val mapname     =\"roomMapWithTable\"

var Curmove     = \"\" 
var curmoveIsForward = false 

//REAL ROBOT
//var StepTime   = 1000 	 
//var PauseTime  = 500 

//VIRTUAL ROBOT
var StepTime   = 330	//for virtual
var PauseTime  = 500

var PauseTimeL  = PauseTime.toLong()
"]	 
	State s0 initial {	    
	    solve( consult("moves.pl")	 )
 		run itunibo.planner.plannerUtil.initAI()
  		run itunibo.planner.moveUtils.loadRoomMap( myself, mapname )	
  		run itunibo.planner.moveUtils.showCurrentRobotState()
	 	["	val MapStr =  itunibo.planner.plannerUtil.getMapOneLine()  "]
	 	forward resourcemodel -m modelUpdate : modelUpdate(roomMap,$MapStr)   
 	}  
	Goto  tableEast
	 
	State tableEast{
 		run itunibo.planner.plannerUtil.setGoal(5,3)
  		run itunibo.planner.moveUtils.doPlan( myself )
 		//solve( dialog(F) )
   	} 
	Goto executePlannedActions //doGoHomeActions 
		
  
	State executePlannedActions{ 
		//solve( showMoves ) 
		solve( retract( move(M) ) ) 
		ifSolved {  
			["Curmove = getCurSol(\"M\").toString() 
              curmoveIsForward=(Curmove == \"w\")
	        "]
		} else { ["Curmove = \"\"; curmoveIsForward=false"]  }  
		//println("executePlannedActions doing $Curmove")
 	}
	Goto checkAndDoAction  if "(Curmove.length>0) " else goalOk 

 	State goalOk{		  
 		run itunibo.planner.moveUtils.showCurrentRobotState()
	 	["	val MapStr =  itunibo.planner.plannerUtil.getMapOneLine()  "]
	 	forward resourcemodel -m modelUpdate : modelUpdate(roomMap,$MapStr)   
 	}
  	
 	//Execute the move if it is a rotation or halt
	State checkAndDoAction{	 }
	Goto doForwardMove if "curmoveIsForward" else doTheMove
	  
	State doTheMove{
		run itunibo.planner.moveUtils.rotate(myself, Curmove, PauseTime)
  	}
	Goto executePlannedActions 
	
 	State doForwardMove{
 		delayVar PauseTimeL  //Otherwise is too fast, even with remote interaction
 		run itunibo.planner.moveUtils.attemptTomoveAhead(myself, StepTime)
	} 
	Transition t0   whenMsg stepOk   -> handleStepOk   
					whenMsg stepFail -> hadleStepFail 	
    	
	State handleStepOk{
 		run itunibo.planner.moveUtils.updateMapAfterAheadOk(myself)
	}
	Goto executePlannedActions
	
 	State hadleStepFail{ 
		println("NEVER HERE!!!")
	}
	
}	
 