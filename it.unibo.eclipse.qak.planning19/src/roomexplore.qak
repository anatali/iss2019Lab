/*
 * If no map exists,
 * 		explore the room boundary by using the planner
 * otherwise
 *      finds the position of the table
 */
System roomexplore
mqttBroker "localhost" : 1883  

Dispatch modelChange  : modelChange( TARGET, VALUE )   

Dispatch onestep       : onestep(DURATION)
Dispatch stepOk        : stepOk(V)		//TODO eliminate  V
Dispatch stepFail      : stepFail(R,T) //R=ok | obstacle, T = time

Event  sonarRobot     : sonar( DISTANCE )	     //from  sonar on robot 

Context ctxRoomExplore    ip [host="localhost" port=8038]    -mqtt 
Context ctxDummyForMind   ip [host="otherresourcelocalhost" port=8035]   -mqtt 

ExternalQActor resourcemodel context ctxDummyForMind

QActor roomexplorer context ctxRoomExplore{     
["
var mapEmpty    = false
var Tback       = 0L
var stepCounter = 0 
var Curmove     = \"\"
var Direction   = \"\" 
var MaxX        = 0
var MaxY        = 0
var TableFound  = false


//var StepTime   = 1000L	//long		/ 
////var RotateTime = 610L	//long		//300L	//for virtual
//var PauseTime  = 500L 

var StepTime   = 330L	//for virtual
var RotateTime = 300L	//for virtual
var PauseTime  = 500L 


"]	
	State s0 initial {	
	    solve( consult("moves.pl")	 )
 		run itunibo.planner.plannerUtil.initAI()
 		run itunibo.planner.moveUtils.loadRoomMap( myself )	//assert mapdims/2
 		solve( mapdims(X,Y) )
 		["mapEmpty = ( getCurSol(\"X\").toString() == \"0\")"]
 	}
	Goto  exploreBoundary //if "mapEmpty"  else findTable
	
	/*
	 * 1)  
	 */ 
	State exploreBoundary{
 		println("MAP AT START")
 		run itunibo.planner.plannerUtil.showMap()
  		solve( direction(D) )   
   		println("DIRECTION: ${getCurSol(\"D\").toString()}")
  	}
	Goto moveAhead  
	
	State moveAhead{
  		run itunibo.planner.moveUtils.doPlannedMove(myself, "w") //update map (there is always a first step)
		run itunibo.planner.plannerUtil.startTimer()
		forward onecellforward -m onestep : onestep($StepTime)	
 		delayVar PauseTime
 	}
	Transition t0   whenMsg stepOk   -> moveAhead   
					whenMsg stepFail -> changeDirection 

	State changeDirection{
  		forward resourcemodel -m modelChange : modelChange(robot,a) 
		delayVar RotateTime //rotate 
		forward resourcemodel -m modelChange : modelChange(robot,h) //stop
		run itunibo.planner.moveUtils.doPlannedMove(myself, "a" )	    //update map
  		solve( direction(D) )   
  		["Direction = getCurSol(\"D\").toString() "] 
   		println("DIRECTION: ${getCurSol(\"D\").toString()}")
		run itunibo.planner.plannerUtil.showMap()
		run itunibo.planner.plannerUtil.saveMap("roomMap.txt")
   		delayVar PauseTime						
  		//solve( dialog(F) )
	}
	//Goto endOfExploreBoundary if "(Direction==\"downDir\")" else moveAhead 
	Goto findTable if "(Direction==\"downDir\")" else moveAhead 
	
	State endOfExploreBoundary{
		println("EXPLORATION ENDS")
 		//run itunibo.planner.plannerUtil.showMap()
 		//run itunibo.planner.plannerUtil.loadMap()		 
 	}

/*
 * ===================================================================0
 */

 	
 	State findTable{
 		println("findTable START")
 		solve( mapdims(MaxX,MaxY ) )
["
MaxX = Integer.parseInt( getCurSol(\"MaxX\").toString() )  
MaxY = Integer.parseInt( getCurSol(\"MaxY\").toString() )  
"] 
 	}
 	Goto doExploreRowOnRight
 	
	State doExploreRowOnRight{
 		solve( curPos(X,Y) )	//here X=0
		//["val X1 = Integer.parseInt( getCurSol(\"X\").toString() ) + 1"]		
		//Rotate left and go ahead				
  		forward resourcemodel -m modelChange : modelChange(robot,a) 
		delayVar RotateTime //rotate 
		forward resourcemodel -m modelChange : modelChange(robot,h) //stop
		run itunibo.planner.moveUtils.doPlannedMove(myself, "a" )	    //update map
  		solve( direction(D) )   
  		["Direction = getCurSol(\"D\").toString() "] 
   		println("DIRECTION: ${getCurSol(\"D\").toString()}")

//		run itunibo.planner.plannerUtil.setGoal(@MaxX,@Y)			 
//		//solve( dialog(F) )
//		run itunibo.planner.moveUtils.doPlan( myself )
 	}
	Goto moveAheadOnRow
	
	State moveAheadOnRow{
  		run itunibo.planner.moveUtils.doPlannedMove(myself, "w") //update map (there is always a first step)
		run itunibo.planner.plannerUtil.startTimer()
		forward onecellforward -m onestep : onestep($StepTime)	
 		delayVar PauseTime		
	}  
 	Transition t0   whenMsg stepOk   -> moveAheadOnRow   
					whenMsg stepFail -> foundTable       //Table or wall?
 
 	State foundTable{
  		solve( curPos(X,Y) )	 
  		solve( direction(D) )   
["
TableFound = Integer.parseInt( getCurSol(\"X\").toString() ) < MaxX &&
             Integer.parseInt( getCurSol(\"Y\").toString() ) > MaxY
Direction = getCurSol(\"D\").toString() 
"] 
 		println("FOUND TABLE DIRECTION: ${getCurSol(\"D\").toString()}")
 	}
 	Goto foundTable if "(Direction==\"\")" else foundTable
 
 
 	State doExploreRowOnLeft{
		solve( mapdims(MaxX,MaxY ) )
		solve( curPos(X,Y) )	//here X=MaxX
		["val Y1 = Integer.parseInt( getCurSol(\"Y\").toString() ) + 1"]			
		run itunibo.planner.plannerUtil.setGoal("0",@Y1)			 
		//solve( dialog(F) )
		run itunibo.planner.moveUtils.doPlan( myself )
 	}
	Goto executePlannedActions if "itunibo.planner.moveUtils.existPlan()"  else endOfJob  
  
    
 
    State executePlannedActions{
 		solve( retract( move(M) ) ) 
		ifSolved {  
			["Curmove = getCurSol(\"M\").toString() 
              curmoveIsForward=(Curmove == \"w\")
	        "]
		} else { ["Curmove = \"\"; curmoveIsForward=false"]  }  
		//println("executePlannedActions doing $Curmove")
 	}
	Goto checkAndDoAction  if "(Curmove.length>0) " else anotherRow 


	State anotherRow{
		
	}
 	//Execute the move if it is a rotation or halt
	State checkAndDoAction{	 }
	Goto doForwardMove if "curmoveIsForward" else doTheMove

	State doTheMove{
//		if "Curmove==\"a\"" { forward resourcemodel -m modelChange : modelChange(robot,l) }
//		if "Curmove==\"d\"" { forward resourcemodel -m modelChange : modelChange(robot,r) }
//		run itunibo.planner.moveUtils.doPlannedMove(myself, Curmove)
  		forward resourcemodel -m modelChange : modelChange(robot,$Curmove) 
		delayVar RotateTime //rotate 
		forward resourcemodel -m modelChange : modelChange(robot,h) //stop
		run itunibo.planner.moveUtils.doPlannedMove(myself, Curmove)
 		delayVar PauseTime		
		//println("doTheMove DONE $Curmove")
 		//solve( dialog(F) )	//to CALIBRATE rotation time
	}
	Goto executePlannedActions 
	
	//Delegate a forward move to onecellforward
	State doForwardMove{
		run itunibo.planner.plannerUtil.startTimer()
		forward onecellforward -m onestep : onestep($StepTime)	
	}
	Transition t0   //whenMsg stopAppl -> stopApplication 
					whenMsg stepOk   -> handleStepOk   
					whenMsg stepFail -> hadleStepFail 
	 
	//onecellforward has completed 
	State handleStepOk{
		run itunibo.planner.moveUtils.doPlannedMove(myself, "w")	
 	}
	Goto executePlannedActions
	
	//onecellforward has found an obstacle
	State hadleStepFail{ 
		println("&&&  FOUND OBSTACLE")
	}

	State backToHome{
		println("&&&  backToHome")
 		solve( direction(D) )
   		println("direction at backToHome: ${getCurSol(\"D\").toString()}")
 		println("MAP BEFORE backToHome")
		run itunibo.planner.plannerUtil.showMap()	
		solve( retractall( move(_) ))		//clean the actor kb
 		run itunibo.planner.plannerUtil.setGoal(0,0)
 		 
 		run itunibo.planner.moveUtils.doPlan( myself )
 		//solve( showMoves ) 
 		//run itunibo.planner.moveUtils.storeMoves( myself, "" )
 	} 
	Goto executePlannedActions   
	
 	State endOfJob{
 		println("endOfJob ")
 		solve( dialog(F) )
 	}
	
	
}	

//Application move step
QActor onecellforward context ctxRoomExplore {
[" var foundObstacle = false; var StepTime = 0L"]  
	State s0 initial {	   
		["foundObstacle = false "]
	} 
	Transition t0 whenMsg onestep -> doMoveForward
	
	State doMoveForward{		  
		onMsg( onestep : onestep( TIME ) ) {
			["StepTime = payloadArg(0).toLong()"]
 			forward resourcemodel -m modelChange : modelChange(robot,w)
			run itunibo.planner.plannerUtil.startTimer()
		}
	} 
	Transition t0 whenTimeVar  StepTime -> endDoMoveForward		
 		          whenEvent sonarRobot  -> handleSonarRobot
		  
	State endDoMoveForward{
		forward resourcemodel -m modelChange : modelChange(robot,h)
		forward roomexplorer -m stepOk : stepOk(ok)  //answer
	}
	Goto s0
	
	//Substitute with an ad-hoc actor for a real robot
	State handleSonarRobot{  //before than the step time
		run itunibo.planner.moveUtils.setDuration(myself)
		printCurrentMessage
 		onMsg ( sonarRobot : sonar( DISTANCE ) ){     
			["val distance = Integer.parseInt( payloadArg(0) ) 
              foundObstacle = (distance<20) "]  
   		}
	}
	Goto stepFail if "foundObstacle" else s0
	
	State stepFail{
		println("&&& onecellforward stepfail ")
		solve( wduration( TIME ) )
		forward roomexplorer -m stepFail : stepFail(obstacle,#TIME)  	
	}
	Goto s0



}    

