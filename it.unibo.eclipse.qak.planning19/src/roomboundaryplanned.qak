/*
 * Builds a map of the room by using the planner
 */
System roomboundaryplanned
mqttBroker "localhost" : 1883 

Dispatch modelChange  : modelChange( TARGET, VALUE )   
Dispatch modelUpdate  : modelUpdate( TARGET, VALUE )
Dispatch onestep       : onestep(DURATION)
Dispatch stepOk        : stepOk(V)		//TODO eliminate  V
Dispatch stepFail      : stepFail(R,T) //R=ok | obstacle, T = time
 
Context ctxBoundaryPlanned    ip [host="localhost" port=8068]  -mqtt
Context ctxDummyForMind   ip [host="otherresourcelocalhost" port=8035]   -mqtt 

ExternalQActor resourcemodel context ctxDummyForMind
ExternalQActor onestepahead  context ctxDummyForMind

QActor roomboudaryexplorer context ctxBoundaryPlanned{      
["
var mapEmpty    = false
val mapname     = \"xxx\"  //\"roomBoundary\"		//
var Tback       = 0
var NumStep     = 0

//REAL ROBOT
//var StepTime   = 1000	 
//var PauseTime  = 500L 

//VIRTUAL ROBOT
var StepTime   = 330	 
var PauseTime  = 250

var PauseTimeL  = PauseTime.toLong()
"]
	State s0 initial {	 
 	    //solve( consult("moves.pl")	 ) 
		run itunibo.planner.plannerUtil.initAI()
		run itunibo.planner.moveUtils.showCurrentRobotState()
 	}
    Goto detectBoundary  
    
    State detectBoundary{ 
    	["NumStep++"]
      	//NO GOAL : JUST ONE STEP ahead
  		run itunibo.planner.plannerUtil.showMap()  
     }
    Goto doAheadMove if "(NumStep<5)" else boundaryFound

 	State doAheadMove{
   		run itunibo.planner.moveUtils.attemptTomoveAhead(myself, StepTime)
	}
	Transition t0   whenMsg stepOk   -> stepDone   
					whenMsg stepFail -> stepFailed 
	 
 	State stepDone{  
 		run itunibo.planner.moveUtils.updateMapAfterAheadOk(myself)
		delayVar PauseTimeL
 	}
	Goto doAheadMove

	//onestepahead has found an obstacle
	State stepFailed{  
		println("&&&  FOUND WALL")
["
val mapStr = \"mapToDo\" //itunibo.planner.plannerUtil.getMap()
println(\"++++++++++++++++++++++++++++++++++++++++  \")
println( mapStr )
println(\"++++++++++++++++++++++++++++++++++++++++ \")  
"]		
		forward resourcemodel -m modelUpdate : modelUpdate(roomMap,"$mapStr")    
		//printCurrentMessage		        
 		onMsg( stepFail : stepFail(Obs,Time) ) { 
 			["Tback=payloadArg(1).toString().toInt() / 2"]
 			println("stepFailed ${payloadArg(1).toString()}")
 		}
  		//Return in cell
  	 	//IMPORTANT: the virtual robot could not work without a back step 		  
 		run itunibo.planner.moveUtils.backToCompensate(myself, Tback, PauseTime)      
 //--------------------------------------------------
 		run itunibo.planner.plannerUtil.wallFound()
//--------------------------------------------------
		run itunibo.planner.moveUtils.rotateLeft(myself, PauseTime)
		//solve( dialog(F) )  
	}   
    Goto detectBoundary
 
 	State boundaryFound{
		run itunibo.planner.plannerUtil.saveMap(mapname)
		println("FINAL MAP")   
 		run itunibo.planner.moveUtils.showCurrentRobotState()
  	}
 	      
}	

 