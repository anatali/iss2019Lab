System roomboundaryplanned
mqttBroker "localhost" : 1883 

Dispatch modelChange  : modelChange( TARGET, VALUE )   
Dispatch onestep       : onestep(DURATION)
Dispatch stepOk        : stepOk(V)		//TODO eliminate  V
Dispatch stepFail      : stepFail(R,T) //R=ok | obstacle, T = time

Event  sonarRobot     : sonar( DISTANCE )	     //from  sonar on robot 

Context ctxBoundaryPlanned    ip [host="localhost" port=8068]  -mqtt
Context ctxDummyForMind   ip [host="otherresourcelocalhost" port=8035]   -mqtt 

ExternalQActor resourcemodel context ctxDummyForMind

QActor planex1 context ctxBoundaryPlanned{      
["
var mapEmpty    = false
var Tback       = 0L
var stepCounter = 0 
var Curmove     = \"\"
var Direction   = \"\" 
var MaxX        = 0
var MaxY        = 0
var CurX        = 0
var CurY        = 0
var GX          = 0
var GY          = 0
var TableFound  = false
var curmoveIsForward = false
var endTableEdge = false
var NunOfTurn       = 0
var NumStep      = 0

//var StepTime   = 1000L	//long		/ 
////var RotateTime = 610L	//long		//300L	//for virtual
//var PauseTime  = 500L 

var StepTime   = 330L	//for virtual
var RotateTime = 300L	//for virtual
var PauseTime  = 500L 


"]
	State s0 initial {	 
		println("&&&  planex0 STARTED")
	    solve( consult("moves.pl")	 ) 
		run itunibo.planner.plannerUtil.initAI()
		println("INITIAL MAP") 
 		//run itunibo.planner.plannerUtil.showMap() 
 	}
    Goto detectBoundary //reachCorner
    
    State detectBoundary{ 
    	["NumStep++"]
      	//NO GOAL : JUST ONE STEP ahead
  		run itunibo.planner.plannerUtil.showMap()  
     }
    Goto doAheadMove if "(NumStep<5)" else boundaryFond

 	State doAheadMove{
		run itunibo.planner.plannerUtil.startTimer()
		forward onecellforward -m onestep : onestep($StepTime)	
	}
	Transition t0   whenMsg stepOk   -> stepDone   
					whenMsg stepFail -> stepFailed 
	 
	//onecellforward has completed 
	State stepDone{  
		run itunibo.planner.plannerUtil.doMove( "w" )	
		delayVar PauseTime
 	}
	Goto doAheadMove

    State reachWallRight{ 
  		run itunibo.planner.plannerUtil.showMap()  
     }
    Goto doAheadMove  
	
	//onecellforward has found an obstacle
	State stepFailed{  
		println("&&&  FOUND WALL")
		printCurrentMessage
		        
 		onMsg( stepFail : stepFail(Obs,Time) ) { 
 			["Tback=payloadArg(1).toString().toLong() / 3 "]
 			println("stepFailed ${payloadArg(1).toString()}")
 		}
 		//Return in cell
  		forward resourcemodel -m modelChange : modelChange(robot,s) 
		delayVar Tback  
		forward resourcemodel -m modelChange : modelChange(robot,h) //stop

//--------------------------------------------------
 		run itunibo.planner.plannerUtil.wallFound()
//--------------------------------------------------

  		forward resourcemodel -m modelChange : modelChange(robot,a) 
		forward resourcemodel -m modelChange : modelChange(robot,h) //stop	
		run itunibo.planner.plannerUtil.doMove( "a" )	    //update map
 
 		//run itunibo.planner.plannerUtil.showMap()
		delayVar PauseTime

		//solve( dialog(F) )  
	}   
    Goto detectBoundary
 
 	State boundaryFond{
		println("FINAL MAP")   
 		run itunibo.planner.plannerUtil.showMap() 
 		run itunibo.planner.plannerUtil.saveMap("roomBoudary")
  	}
 	      
}	


//==============================================================================
QActor onecellforward context ctxBoundaryPlanned {
[" var foundObstacle = false; var StepTime = 0L"]  
	State s0 initial {	   
		["foundObstacle = false "]
	} 
	Transition t0 whenMsg onestep -> doMoveForward
	
	State doMoveForward{		  
		onMsg( onestep : onestep( TIME ) ) {
			["StepTime = payloadArg(0).toLong()"]
 			forward resourcemodel -m modelChange : modelChange(robot,w)
			run itunibo.planner.plannerUtil.startTimer()
		}
	} 
	Transition t0 whenTimeVar  StepTime -> endDoMoveForward		
 		          whenEvent sonarRobot  -> handleSonarRobot
		  
	State endDoMoveForward{
		forward resourcemodel -m modelChange : modelChange(robot,h)
		forward planex1 -m stepOk : stepOk(ok)  //answer
	}
	Goto s0
	
	//Substitute with an ad-hoc actor for a real robot
	State handleSonarRobot{  //before than the step time
		run itunibo.planner.moveUtils.setDuration(myself)
		printCurrentMessage
 		onMsg ( sonarRobot : sonar( DISTANCE ) ){     
			["val distance = Integer.parseInt( payloadArg(0) ) 
              foundObstacle = (distance<20) "]  
   		}
	}
	Goto stepFail if "foundObstacle" else s0
	
	State stepFail{
		println("&&& onecellforward stepfail ")
		solve( wduration( TIME ) )
		forward planex1 -m stepFail : stepFail(obstacle,#TIME)  	
	}
	Goto s0
 
}  
 